<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
  <title>SHOWMOBILE</title>
  <style>
      :root{
          --gap:14px;
          --muted:#9ca3af; /* Grigio pi√π chiaro per leggibilit√† su scuro */
          --b:#4b5563;     /* Bordo molto pi√π visibile (grigio medio) */
          --ok:#10b981;
          --warn:#f59e0b;
          --err:#ef4444;
          --bg:#0b0f14;
          --card:#111827;  /* Sfondo card leggermente pi√π chiaro del body */
          --text:#f3f4f6;
          --accent:#6366f1; /* Indaco brillante */
          --vh: 1vh;
      }
      
      *{box-sizing:border-box}
      
      html,body{height:100%}
      
      body{
          margin:0;
          background:var(--bg);
          color:var(--text);
          font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
          -webkit-font-smoothing:antialiased;
      }
      
      header{
          position:sticky;
          top:0;
          background:rgba(11, 15, 20, 0.9);
          backdrop-filter:blur(10px);
          border-bottom:1px solid var(--b);
          z-index:1000;
      }
      
      .wrap{
          max-width:980px;
          margin:0 auto;
          padding:16px;
      }
      
      h1{
          margin:0 0 6px;
          font-size:20px;
          letter-spacing:.2px;
          line-height:1.2;
          display:flex;
          flex-wrap:wrap;
          align-items:baseline;
          gap:8px;
      }
      
      h1 .opNameTag{
          font-size:12px;
          line-height:1.2;
          color:#d1d5db;
          background:#374151;
          border:1px solid #6b7280;
          border-radius:8px;
          padding:3px 6px;
          font-weight:500;
      }
      
      nav{
          display:flex;
          gap:8px;
          flex-wrap:wrap;
      }
      
      nav button{
          flex:1 1 auto;
          min-width:0;
          border:1px solid var(--b);
          background:#1f2937;
          border-radius:12px;
          padding:10px 12px;
          cursor:pointer;
          color:var(--text);
          font-size:14px;
          line-height:1.2;
          text-align:center;
          transition: background 0.2s;
      }
      
      nav button.active{
          background:var(--accent);
          border-color:var(--accent);
          color:#fff;
          font-weight:600;
          box-shadow: 0 0 12px rgba(99, 102, 241, 0.4);
      }
      
      nav button[data-tab="tab-home"]{
          flex-basis:100%;
      }
      
      @media(min-width:768px){
          nav button{
              flex-grow:0;
              flex-basis:auto;
              font-size:13px;
              padding:8px 10px;
              border-radius:10px;
          }
          nav button[data-tab="tab-home"]{
              flex-basis:auto;
          }
      }
      
      h2{
          margin:14px 0 8px;
          font-size:18px;
      }
      
      .grid{
          display:grid;
          gap:var(--gap);
      }
      
      .cols-2{
          grid-template-columns:1fr;
      }
      
      @media(min-width:900px){
          .cols-2{grid-template-columns:1fr 1fr}
      }
      
      .card{
          background:var(--card);
          border:1px solid var(--b);
          border-radius:16px;
          padding:14px;
          position:relative;
          box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3);
      }
      
      label{
          font-size:12px;
          color:var(--muted);
          display:block;
          margin-bottom:6px;
      }
      
      input,
      textarea,
      select{
          width:100%;
          border:1px solid var(--b);
          background:#030712; /* Input molto scuro per contrasto */
          border-radius:12px;
          padding:12px 14px;
          color:var(--text);
          font-family:inherit;
          font-size:16px;
          line-height:1.3;
      }
      
      input::placeholder,
      textarea::placeholder{
          color:#6b7280;
      }
      
      table{
          width:100%;
          border-collapse:collapse;
      }
      
      th,
      td{
          padding:12px;
          border-bottom:1px solid var(--b);
          text-align:left;
          font-size:14px;
          vertical-align:top;
      }
      
      .table-scroll{
          width:100%;
          overflow-x:auto;
      }
      
      .row{
          display:flex;
          flex-wrap:wrap;
          gap:10px;
          align-items:flex-end;
      }
      
      .row .btn{
          flex-shrink:0;
      }
      
      .row.actions-wrap{
          justify-content:flex-start;
      }
      
      .row.actions-wrap .btn{
          flex:1 1 calc(50% - 10px);
          text-align:center;
      }
      
      @media(min-width:480px){
          .row.actions-wrap .btn{
              flex:0 0 auto;
          }
      }
      
      .btn{
          border:1px solid var(--b);
          border-radius:12px;
          padding:12px 14px;
          background:var(--accent);
          color:#fff;
          cursor:pointer;
          font-size:15px;
          line-height:1.2;
          font-weight: 500;
      }
      
      .btn.ghost{
          background:#1f2937;
          color:var(--text);
          border-color: var(--b);
      }
      
      .btn.warnBtn{
          background:#991b1b;
          border-color:#ef4444;
      }
      
      .btn.sm{
          padding:8px 10px;
          font-size:13px;
          line-height:1.2;
          border-radius:10px;
      }
      
      @media(min-width:1024px){
          .btn{
              padding:10px 12px;
              font-size:14px;
          }
          .btn.sm{
              padding:6px 8px;
              font-size:12px;
          }
      }
      
      .muted{color:#9ca3af}
      .ok{color:var(--ok)}
      .warn{color:var(--warn)}
      .err{color:var(--err)}
      
      .qrbox{
          display:flex;
          align-items:center;
          justify-content:center;
          min-height:260px;
          background:#000;
          border:1px dashed var(--b);
          border-radius:16px;
      }
      
      .qrbox canvas{
          width:260px !important;
          height:260px !important;
          image-rendering:pixelated;
      }
      
      .mono{
          font-family:ui-monospace,Menlo,Consolas,monospace;
          white-space:pre-wrap;
          font-size:13px;
          line-height:1.4;
      }
      
      video,
      canvas{
          max-width:100%;
      }
      
      .hidden{display:none}
      
      .home-cta{
          display:grid;
          grid-template-columns:1fr;
          gap:12px;
          margin-top:8px;
      }
      
      .cta{
          display:flex;
          align-items:center;
          gap:12px;
          border:1px solid var(--b);
          background:var(--card);
          border-radius:16px;
          padding:16px;
          cursor:pointer;
      }
      
      .cta .icon{
          width:44px;
          height:44px;
          border-radius:12px;
          display:flex;
          align-items:center;
          justify-content:center;
          background:#1f2937;
          font-size:20px;
          flex-shrink:0;
      }
      
      .cta .title{
          font-weight:600;
          font-size:15px;
          line-height:1.3;
          color:var(--text);
      }
      
      .cta .desc{
          font-size:12px;
          color:var(--muted);
          line-height:1.4;
      }
      
      @media(min-width:760px){
          .home-cta{
              grid-template-columns:1fr 1fr;
          }
      }
      
      .progress{
          height:12px;
          background:#1f2937;
          border-radius:999px;
          overflow:hidden;
          border:1px solid var(--b);
      }
      
      .progress>span{
          display:block;
          height:100%;
          background:linear-gradient(90deg,#22c55e,#16a34a);
          width:0%;
          transition: width 0.3s ease;
      }
      
      .r-toolbar{
          position:sticky;
          top:0;
          background:rgba(17, 24, 39, 0.95);
          backdrop-filter: blur(8px);
          border-bottom:1px solid var(--b);
          border-radius:16px 16px 0 0;
          padding-bottom:12px;
          z-index:3;
          display:flex;
          flex-direction:column;
          gap:12px;
      }
      
      .r-toolbar-sec{
          display:flex;
          flex-wrap:wrap;
          gap:10px;
      }
      
      .r-toolbar-sec .btn{
          flex:1 1 calc(50% - 10px);
          text-align:center;
      }
      
      @media(min-width:600px){
          .r-toolbar-sec .btn{
              flex:0 0 auto;
          }
      }
      
      .r-progress-block{
          border-top:1px solid var(--b);
          padding-top:8px;
      }
      
      .r-table-wrap{
          max-height:65vh;
          overflow-y:auto;
          margin-top:12px;
          border-top:1px solid var(--b);
          padding-top:12px;
      }
      
      #rTbl th, #rTbl td{
          font-size:14px;
          line-height:1.3;
      }
      
      .rCtrl{
          display:flex;
          align-items:center;
          gap:6px;
          flex-wrap:nowrap;
      }
      
      .qtyBtn{
          background:#1f2937;
          border:1px solid var(--b);
          color:#fff;
          font-size:20px;
          line-height:1;
          border-radius:10px;
          min-width:44px;
          min-height:44px;
          padding:0;
          text-align:center;
          flex-shrink:0;
          display:flex;
          align-items:center;
          justify-content:center;
          user-select:none;
      }
      
      .qtyBtn.plus{
          background:#065f46;
          border-color:#065f46;
      }
      
      .qtyBtn.minus{
          background:#7f1d1d;
          border-color:#7f1d1d;
      }
      
      .rQtyInputBig{
          width:64px;
          text-align:center;
          font-size:18px;
          line-height:1.2;
          background:#030712;
          border:1px solid var(--b);
          border-radius:10px;
          color:var(--text);
          padding:10px;
      }
      
      /* ----------- WEBCAM (PATCH) ----------- */
      #cameraOverlay{
          position:fixed;
          inset:0;
          background:#000;
          color:#fff;
          z-index:3000;
          display:none;             /* diventa flex in startCameraOverlay */
          flex-direction:column;
          height:calc(var(--vh, 1vh) * 100); /* iOS vh reale */
      }
      
      #cameraHeader{
          display:flex;
          justify-content:space-between;
          align-items:center;
          padding:12px 16px;
          background:rgba(0,0,0,.6);
          color:#fff;
          font-size:14px;
          line-height:1.3;
          z-index:10;
      }
      #cameraHeader .cam-status{
          flex:1;
          min-width:0;
          color:#fff;
      }
      #cameraHeader .cam-actions{
          display:flex;
          gap:10px;
              }
      #cameraHeader button{
          background:#111827;
          border:1px solid #374151;
          color:#fff;
          border-radius:10px;
          padding:8px 10px;
          font-size:13px;
          line-height:1.2;
      }
      
      #cameraVideoWrap{
          flex:1;                 /* occupa tutto lo spazio sotto l‚Äôheader */
          min-height:0;
          position:relative;
          overflow:hidden;
          background:#000;
          display:block;
      }
      
      #cameraVideo{
          position:absolute;
          inset:0;
          width:100%;
          height:100%;
          object-fit:cover;       /* full-bleed stabile; usa 'contain' se preferisci vedere tutto */
          background:#000;
          border-radius:0;
      }
      
      #cameraCanvas{
          display:none;
      }
      /* --------- FINE PATCH WEBCAM ----------- */
      
      /* ----------- LOGIN OVERLAY (PATCH) ----------- */
      #loginOverlay{
          position:fixed !important;
          inset:0;
          height:calc(var(--vh, 1vh) * 100);
          background:rgba(0,0,0,.8);
          color:#fff;
          z-index:4000;           /* sopra a cameraOverlay */
          display:flex;
          align-items:center;
          justify-content:center;
          padding:24px;
      }
      /* --------- FINE LOGIN OVERLAY ----------- */
      /* COUNTER OVERLAY */
      #counterOverlay{
          position:fixed;
          inset:0;
          height:calc(var(--vh, 1vh) * 100);
          background:rgba(0,0,0,.85);
          color:#fff;
          z-index:5000;
          display:none;
          flex-direction:column;
          backdrop-filter: blur(4px);
      }
      #counterHeader{
          display:flex;
          align-items:center;
          justify-content:space-between;
          gap:12px;
          padding:14px 16px;
          background:rgba(17, 24, 39, 0.95);
          border-bottom:1px solid var(--b);
      }
      #counterTitle{
          font-size:16px;
          line-height:1.3;
          font-weight:600;
          white-space:nowrap;
          overflow:hidden;
          text-overflow:ellipsis;
      }
      .hdr-actions{
          display:flex;
          gap:10px;
      }
      .hdr-btn{
          background:#1f2937;
          border:1px solid var(--b);
          color:#fff;
          border-radius:10px;
          padding:8px 12px;
          font-size:14px;
          line-height:1.2;
          cursor:pointer;
          display:flex;
          align-items:center;
          justify-content:center;
      }
      .hdr-btn.active{
          background:var(--accent);
          border-color:var(--accent);
          color:#fff;
      }
      
      #counterBody{
          flex:1;
          display:flex;
          flex-direction:column;
          gap:16px;
          padding:16px;
      }
      .cntInfo{
          display:flex;
          gap:12px;
          flex-wrap:wrap;
          font-size:14px;
          color:#d1d5db;
      }
      .cntValue{
          font-size:64px;
          font-weight:700;
          text-align:center;
          padding:12px 0;
          text-shadow: 0 0 20px rgba(99, 102, 241, 0.3);
      }
      .cntButtons{
          display:grid;
          grid-template-columns:1fr 1fr;
          gap:14px;
          margin-top:8px;
      }
      .bigCountBtn{
          display:flex;
          align-items:center;
          justify-content:center;
          min-height:120px;
          font-size:42px;
          font-weight:700;
          border-radius:24px;
          cursor:pointer;
          border:1px solid var(--b);
          background:#111827;
          color:#fff;
          user-select:none;
          -webkit-tap-highlight-color:transparent;
          transition: transform 0.1s, background 0.1s;
      }
      .bigCountBtn:active {
          transform: scale(0.96);
      }
      .bigCountBtn.minus{
          background:rgba(127, 29, 29, 0.3);
          border-color:#7f1d1d;
      }
      .bigCountBtn.plus{
          background:rgba(6, 95, 70, 0.3);
          border-color:#065f46;
      }
      .presetRow{
          display:grid;
          grid-template-columns:repeat(6,1fr);
          gap:8px;
      }
      .presetBtn{
          border:1px solid var(--b);
          background:#1f2937;
          color:#fff;
          border-radius:12px;
          padding:12px 8px;
          font-size:16px;
          font-weight:600;
          cursor:pointer;
          text-align:center;
      }
      .presetBtn.active{
        background:var(--accent);
        border-color:var(--accent);
        color:#fff;
      }
      .cntFoot{
          margin-top:auto;
          text-align:center;
          color:#9aa6b2;
          font-size:12px;
      }
      /* FINE COUNTER OVERLAY */
      /* FLASH VISIVO PER CONTEGGIO */
      #tickFlash{
        position:fixed;
        inset:0;
        pointer-events:none;
        background:#ffffff;
        opacity:0;
        transition:opacity 80ms ease-out;
        z-index:99999; /* Molto alto per coprire tutto */
      }
      #tickFlash.show{
        opacity:0.6;
      }
      /* üî† Tutti i campi testuali scrivono in MAIUSCOLO */
      input[type="text"], textarea {
        text-transform: uppercase;
      }
      /* --- Mobile-first enhancements --- */
      nav.noprint{
        display:flex;
        flex-direction:column;
        gap:6px;
      }
      .nav-scroll{
        display:flex;
        gap:8px;
        flex-wrap:nowrap;
        overflow-x:auto;
        padding-bottom:4px;
        -webkit-overflow-scrolling:touch;
      }
      .nav-scroll::-webkit-scrollbar{
        display:none;
      }
      nav.noprint button{
        white-space:nowrap;
        flex:0 0 auto;
      }
      #status{
        font-size:12px;
      }
      nav.noprint button.active{
        position:relative;
      }
      nav.noprint button.active::after{
        content:"";
        position:absolute;
        left:20%;
        right:20%;
        bottom:-3px;
        height:2px;
        border-radius:999px;
        background:#fff;
      }

      .btn:active,
      .qtyBtn:active,
      .bigCountBtn:active,
      .cta:active{
        transform:scale(0.97);
        transition:transform 80ms ease-out;
      }
      
      /* Miglioramento UX focus input */
      input:focus,
      textarea:focus,
      select:focus{
        outline:none;
        border-color:var(--accent);
        box-shadow:0 0 0 2px rgba(99, 102, 241, 0.5); /* Accent con opacit√† */
      }

      #loginCard{
        max-width:360px;
        width:100%;
        background:#0f141b;
        border-radius:16px;
        border:1px solid #1b2230;
        padding:16px;
      }
      #loginCard h2{
        margin-top:0;
        margin-bottom:8px;
        font-size:18px;
      }
      #loginCard p{
        font-size:13px;
        color:#9aa6b2;
        margin-bottom:12px;
      }

      #scanFrame{
        position:absolute;
        inset:15%;
        border:2px solid rgba(255,255,255,.7);
        border-radius:12px;
        box-shadow:0 0 0 9999px rgba(0,0,0,.35);
        pointer-events:none;
      }

      @media(max-width:480px){
        .wrap{
          padding:10px;
        }
        h1{
          font-size:18px;
        }
        h2{
          font-size:16px;
        }
        .card{
          padding:12px;
        }
        input,
        textarea,
        select{
          font-size:15px;
          padding:10px 12px;
        }
        .cntValue{
          font-size:42px;
        }
        .bigCountBtn{
          min-height:100px;
          font-size:36px;
        }
      }

      @media(max-width:600px){
        .table-scroll{
          overflow-x:visible;
        }
        #itemsTbl,
        #itemsTbl thead,
        #itemsTbl tbody,
        #itemsTbl th,
        #itemsTbl td,
        #itemsTbl tr,
        #rTbl,
        #rTbl thead,
        #rTbl tbody,
        #rTbl th,
        #rTbl td,
        #rTbl tr{
          display:block;
          width:100%;
        }

        #itemsTbl thead,
        #rTbl thead{
          display:none;
        }

        #itemsTbl tr,
        #rTbl tr{
          /* CARD EFFECT MOBILE */
          margin-bottom:12px;
          border:1px solid var(--b);
          border-radius:12px;
          padding: 12px 14px;
          background:#111827;
          box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.4);
          cursor: pointer; /* Indice di cliccabilit√† */
          position: relative;
        }
        
        /* Nascondi colonna # */
        #itemsTbl tr td:first-child,
        #rTbl tr td:first-child {
            display: none;
        }

        #itemsTbl td,
        #rTbl td{
          border-bottom:none;
          padding:4px 0;
          font-size:14px;
        }
        
        /* DESCRIZIONE IN EVIDENZA */
        #rTbl td[data-label="Descrizione"] {
          border-bottom: 1px solid var(--b);
          padding-bottom: 8px;
          margin-bottom: 8px;
          font-weight: 700;
          font-size: 15px;
          color: #fff;
        }

        #itemsTbl td::before,
        #rTbl td::before{
          content:attr(data-label);
          display:block;
          font-size:11px;
          color:var(--muted);
          margin-bottom:2px;
          font-weight: 500;
          text-transform: uppercase;
        }

        #itemsTbl td:last-child,
        #rTbl td:last-child{
          margin-top:4px;
        }
        
        /* RIENTRO MOBILE: Layout a due colonne */
        #rTbl td[data-label="Prev."],
        #rTbl td[data-label="Manca"] {
            display: inline-block;
            width: 48%;
            vertical-align: top;
        }
        
        #rTbl td[data-label="Manca"] {
            color: var(--warn);
            font-weight: 700;
        }
        
        /* Nascondi colonne input classiche su mobile */
        #rTbl td[data-label="Rientro"],
        #rTbl td[data-label="Controlli"] {
            display: none !important;
        }
        
        /* Icona "tap" sulla riga */
        #rTbl tr::after {
            content: "üñê";
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 18px;
            opacity: 0.2;
            filter: grayscale(1);
        }
      }

      @media(min-width:768px){
        nav.noprint{
          flex-direction:row;
          align-items:center;
        }
        .nav-scroll{
          flex-wrap:wrap;
          overflow-x:visible;
          padding-bottom:0;
        }
        #status{
          margin-left:auto;
          text-align:right;
        }
      }
      
      /* üÜï Stile per il bottone Rientro con icona */
      nav button[data-tab="tab-rientro"]::before {
        content: "‚úì ";
      }

  </style>
</head>

          <div id="counterOverlay" aria-modal="true" role="dialog">
            <div id="counterHeader">
              <div id="counterTitle">Contatore</div>
              <div class="hdr-actions">
                 <button id="cntSoundToggle" class="hdr-btn" aria-label="Suono">üîä</button>
                 <button id="counterClose" class="hdr-btn" aria-label="Chiudi">‚úï</button>
              </div>
            </div>
            <div id="counterBody">
              <div class="cntInfo">
                <div><strong>Descrizione:</strong> <span id="cntDesc" style="font-weight:700;color:#fff"></span></div>
                <div style="margin-top:4px"><strong>Previsto:</strong> <span id="cntPrev"></span></div>
              </div>
              <div class="cntValue" id="cntValue">0</div>
              <div class="cntButtons">
                <div class="bigCountBtn minus" id="cntMinus">‚àí</div>
                <div class="bigCountBtn plus"  id="cntPlus">+</div>
              </div>
              <div class="presetRow" style="margin-top:10px">
                <button class="presetBtn" data-step="1">1</button>
                <button class="presetBtn" data-step="2">2</button>
                <button class="presetBtn" data-step="5">5</button>
                <button class="presetBtn" data-step="10">10</button>
              </div>
              <div class="row" style="justify-content:center;margin-top:20px">
                <button id="cntReset" class="btn ghost" style="width:100%">Azzera conteggio</button>
              </div>
              <div class="cntFoot">Tocca per contare.</div>
            </div>
          </div>
<body>
  <header>
    <div class="wrap">
      <h1>
        Inventario QR
        <span id="opNameTag" class="opNameTag hidden"></span>
      </h1>
      <nav class="noprint">
        <div class="nav-scroll">
          <button data-tab="tab-home" class="active">Home</button>
          <button data-tab="tab-lista">Crea lista</button>
          <button data-tab="tab-qr">QR & Stampa</button>
          <button data-tab="tab-decode">Leggi lista</button>
          <button data-tab="tab-rientro">Spunta</button>
        </div>
        <span id="status" class="muted"></span>
      </nav>
    </div>
  </header>

  <div class="wrap">
    <section id="tab-home" class="tab">
      <div class="home-cta">
        <div class="cta" data-go="tab-lista">
          <div class="icon">üìù</div>
          <div>
            <div class="title">Crea lista</div>
            <div class="desc">ID baule, evento, materiali, PDF/etichetta.</div>
          </div>
        </div>
        <div class="cta" data-go="tab-decode">
          <div class="icon">üì∑</div>
          <div>
            <div class="title">Leggi lista</div>
            <div class="desc">Scansiona QR o PDF per controllare / caricare rientro.</div>
          </div>
        </div>
      </div>
    </section>

    <section id="tab-lista" class="tab hidden">
      <h2>Lista articoli</h2>
      <div class="grid cols-2">
        <div class="card">
          <div class="row">
            <div style="flex:1">
              <label>ID baule</label>
              <input id="boxId" placeholder="Es. B-07">
            </div>
            <div style="flex:2">
              <label>Evento</label>
              <input id="eventName" placeholder="Es. Concerto Piazza">
            </div>
          </div>
          <div class="row" style="margin-top:10px">
            <div style="flex:3">
              <label>Descrizione</label>
              <input id="desc" placeholder="Es. Faro LED PAR 64">
            </div>
            <div style="flex:1">
              <label>Quantit√†</label>
              <input id="qty" type="number" min="1" value="1">
            </div>
            <button id="addItem" class="btn">Aggiungi</button>
          </div>
        </div>
        <div class="card">
          <div class="row actions-wrap">
            <button id="saveLocal" class="btn ghost">Salva in locale</button>
            <button id="loadLocal" class="btn ghost">Carica da locale</button>
            <button id="clearList" class="btn ghost warnBtn">Svuota lista</button>
            <button id="exportJson" class="btn ghost">Esporta JSON</button>
          </div>
          <div class="muted" style="margin-top:6px">Il salvataggio locale usa <code>localStorage</code>.</div>
        </div>
      </div>

      <div class="card">
        <div class="table-scroll">
          <table id="itemsTbl">
            <thead>
              <tr>
                <th>#</th>
                <th>Descrizione</th>
                <th>Q.t√†</th>
                <th class="noprint">Azioni</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
    </section>

    <section id="tab-qr" class="tab hidden">
      <h2>QR & Stampa</h2>
      <div class="grid cols-2">
        <div class="card">
          <div class="row">
            <div style="flex:1;min-width:140px">
              <label>Produzione</label>
              <input id="prodName" placeholder="es. Festival XYZ">
            </div>
            <div style="flex:1;min-width:140px">
              <label>Posizione</label>
              <input id="posName" placeholder="es. Palco lato DX">
            </div>
          </div>

          <div class="row" style="margin-top:10px">
            <div style="flex:1;min-width:140px">
              <label>Note</label>
              <input id="noteField" placeholder="es. FOH / wedge spare">
            </div>
            <div style="flex:1;min-width:140px">
              <label>Colore etichetta</label>
              <select id="colorSel">
                <option value="0">Rosso</option>
                <option value="1">Arancione</option>
                <option value="2">Giallo</option>
                <option value="3">Verde</option>
                <option value="4">Blu</option>
                <option value="5">Viola</option>
                <option value="6">Bianco/Nessuno</option>
              </select>
            </div>
          </div>
          
          <div class="row" style="margin-top:8px">
            <label style="display:flex;align-items:center;gap:8px;font-size:13px">
              <input type="checkbox" id="watermarkToggle" style="width:auto;flex:0 0 auto;">
              <span>STAMPA NOTA COME WATERMARK DIAGONALE SUL PDF</span>
            </label>
          </div>

          <div class="row" style="margin-top:10px">
            <button id="btnGenQR" class="btn">Genera QR / Aggiorna anteprima</button>
            <button id="btnDownloadPNG" class="btn ghost" disabled>Scarica PNG QR</button>
            <button id="btnPrint" class="btn ghost" disabled>Stampa etichetta</button>
            <button id="btnPDFMain" class="btn ghost" disabled>PDF etichetta</button>
          </div>
          <div class="muted" style="margin-top:6px">
            QRJ1 (zlib+Base45) ‚Ä¢ ECC=H ‚Ä¢ QR fisso grande per lettura al buio.<br>
            Il bordo colore segue quello scelto qui.
          </div>

          <div id="qrBox" class="qrbox" aria-live="polite"></div>
          <div id="encInfo" class="muted"></div>
        </div>

        <div class="card">
          <label>JSON canonico utilizzato</label>
          <textarea id="jsonCanon" rows="16" class="mono" readonly></textarea>
          <div class="muted">SHA-256: <span id="sha256" class="mono"></span></div>
        </div>
      </div>
    </section>

    <section id="tab-decode" class="tab hidden">
      <h2>Leggi/Verifica QR o PDF</h2>
      <div class="grid cols-2">
        <div class="card">
          <div class="row">
            <div style="flex:1;min-width:180px">
              <label>Carica immagine o PDF</label>
              <input id="fileInput" type="file" accept="image/*,application/pdf">
            </div>

            <div style="flex:1;min-width:180px">
              <label>Scatta foto QR (solo immagine)</label>
              <input id="cameraShot" type="file" accept="image/*" capture="environment">
            </div>
          </div>

          <div style="margin-top:10px">
            <label>‚Ä¶oppure usa webcam live (fullscreen)</label>
            <div class="row">
              <button id="btnCam" class="btn ghost">Apri webcam</button>
            </div>
          </div>

          <div id="decStatus" class="muted" style="margin:12px 0 8px"></div>

          <label style="margin-top:12px;display:block;">Testo letto</label>
          <div id="rawOut" class="mono muted"></div>

          <div class="row" style="margin-top:10px">
            <button id="btnSetCurrent" class="btn" disabled>Usa come lista corrente</button>
            <button id="btnCompare" class="btn ghost" disabled>Confronta con lista corrente</button>
          </div>
        </div>
        <div class="card">
          <label>JSON ricostruito</label>
          <textarea id="jsonDecoded" rows="16" class="mono"></textarea>
          <div id="cmpResult" class="muted"></div>
        </div>
      </div>
    </section>

    <section id="tab-rientro" class="tab hidden">
      <h2>Spunta articoli</h2>
      <div class="card">
        <div class="r-toolbar">
          <div class="r-toolbar-sec">
            <button id="rReset" class="btn ghost">Azzera tutto</button>
            <button id="rAll"   class="btn ghost">Tutti rientrati</button>
            <button id="rExport" class="btn ghost">Esporta CSV</button>
            <button id="rPDF" class="btn">PDF rientro</button>
          </div>

          <div class="r-progress-block">
            <div class="muted" style="margin:8px 0 6px">Avanzamento rientro</div>
            <div class="progress" aria-label="Progresso rientro"><span id="rBar" style="width:0%"></span></div>
            <div id="rPct" class="muted" style="margin-top:6px">0% ‚Ä¢ 0/0</div>
            <div id="rInfo" class="muted"></div>
          </div>
        </div>

        <div class="r-table-wrap">
          <div class="table-scroll">
            <table id="rTbl">
              <thead>
                <tr>
                  <th>#</th>
                  <th>Descrizione</th>
                  <th>Prev.</th>
                  <th>Rientro</th>
                  <th>Manca</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
        </div>

      </div>
    </section>
  </div>

  <div id="loginOverlay">
    <div id="loginCard">
      <h2>Chi sta usando l'app?</h2>
      <p>Metti il tuo nome. Verr√† stampato sull'etichetta e sul PDF.<br>Rimane salvato in questo dispositivo.</p>
      <div class="row" style="gap:10px">
        <input id="loginNameInput" placeholder="Es. Luca R." autocomplete="name">
        <button id="loginBtn" class="btn">Entra</button>
      </div>
    </div>
  </div>

  <div id="cameraOverlay">
    <div id="cameraHeader">
      <div class="cam-status" id="camStatus">Inizializzo camera‚Ä¶</div>
      <div class="cam-actions">
        <button id="toggleFlashBtn" class="hidden">Flash</button>
        <button id="closeCamBtn" class="btn sm ghost" style="background:#7f1d1d;border-color:#b91c1c">Chiudi</button>
      </div>
    </div>
    <div id="cameraVideoWrap">
      <video id="cameraVideo" autoplay playsinline muted></video>
      <div id="scanFrame"></div>
      <canvas id="cameraCanvas"></canvas>
    </div>
  </div>

  <script>
    const CACHE_VERSION='qrj1-mobile-v5-enhanced';
    const PRECACHE=[
      'https://cdn.jsdelivr.net/pyodide/v0.25.1/full/pyodide.js',
      'https://cdn.jsdelivr.net/pyodide/v0.25.1/full/pyodide.asm.wasm',
      'https://cdn.jsdelivr.net/pyodide/v0.25.1/full/pyodide.asm.data',
      'https://cdn.jsdelivr.net/pyodide/v0.25.1/full/packages.json',

      'https://cdn.jsdelivr.net/npm/@zxing/library@0.21.2/umd/index.min.js',
      'https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js',
      'https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.js',

      'https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js',
      'https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.min.js',
      'https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.worker.min.js'
    ];

    if('serviceWorker' in navigator){
      const sw=`
        const C='${CACHE_VERSION}', PREC=${JSON.stringify(PRECACHE)};
        self.addEventListener('install',e=>e.waitUntil((async()=>{
          const c=await caches.open(C);
          await c.addAll(PREC);
          self.skipWaiting();
        })()));
        self.addEventListener('activate',e=>e.waitUntil((async()=>{
          const ks=await caches.keys();
          await Promise.all(ks.map(k=>{if(k!==C)return caches.delete(k)}));
          self.clients.claim();
        })()));
        self.addEventListener('fetch',e=>{
          const u=e.request.url;
          if (PREC.some(p=>u.startsWith(p.split('/').slice(0,5).join('/'))||u===p)){
            e.respondWith((async()=>{
              const c=await caches.open(C);
              const m=await c.match(e.request);
              if(m) return m;
              try{
                const f=await fetch(e.request,{cache:'no-store'});
                if(f&&f.ok) c.put(e.request,f.clone());
                return f;
              }catch{
                return m||Response.error();
              }
            })());
          }
        });
      `;
      const blob=new Blob([sw],{type:'text/javascript'});
      const url=URL.createObjectURL(blob);
      navigator.serviceWorker.register(url).catch(()=>{});
    }
      /* üî† Conversione automatica in MAIUSCOLO per tutti gli input di testo */
      document.addEventListener('input', (e) => {
        const el = e.target;
        if ((el.tagName === 'INPUT' && el.type === 'text') || el.tagName === 'TEXTAREA') {
          const pos = el.selectionStart; // per non perdere il cursore
          el.value = el.value.toUpperCase();
          el.setSelectionRange(pos, pos);
        }
      });
      /* üö´ Disattiva correzione automatica e capitalizzazione delle tastiere mobili */
      window.addEventListener('DOMContentLoaded', () => {
        document.querySelectorAll('input[type="text"], textarea').forEach(el => {
          el.autocorrect = "off";
          el.autocapitalize = "characters";
          el.spellcheck = false;
        });
      });
      /* ‚å®Ô∏è Intercetta "Enter" per prevenire refresh involontari su mobile/form impliciti */
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          const tagName = e.target.tagName;
          const type = e.target.type;
          
          // Previene il refresh se non √® un textarea (dove Enter √® una nuova riga)
          if (tagName === 'INPUT' && type !== 'submit') {
            const hasExplicitButton =
              e.target.closest('.row')?.querySelector('button') ||
              document.activeElement?.closest('.row')?.querySelector('button');

            // Se c'√® un bottone adiacente (es. Aggiungi), simula il click, altrimenti previeni il default
            if (hasExplicitButton && e.target.id !== 'loginNameInput') {
              // eccezione per il login gestito separatamente
              hasExplicitButton.click();
              e.preventDefault();
            } else if (e.target.id !== 'loginNameInput') {
              e.preventDefault();
            }
          }
        }
      });
  </script>

  <script>
    const PYODIDE_URL="https://cdn.jsdelivr.net/pyodide/v0.25.1/full/pyodide.js";
    const ZXING_URL="https://cdn.jsdelivr.net/npm/@zxing/library@0.21.2/umd/index.min.js";
    const JSQR_URL="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js";
    const QRG_URL="https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.js";
    const JSPDF_URL="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js";
    const PDFJS_URL="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.min.js";
    const PDFJS_WORKER_URL="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.worker.min.js";
    const APP_URL = "https://showtechnologies.github.io/SMARTLABEL/index.html";

    let pyodide,
        zxingReader=null,
        barcodeDetector=null,
        currentQRCanvas=null,
        decodedObj=null;

    let jsPDFmod=null,
        pdfjsLib=null;

    // camera state
    let camStream=null;
    let camScanning=false;
    let camTrack=null;
    let torchEnabled=false;

    // stato globale
    const KEY_STORE='qrj1_simple_list_v5';
    const KEY_OP='qrj1_operator';
    let state = loadLocal() || {
      v:1,
      t:today(),
      b:"",
      e:"",
      p:"",
      pos:"",
      note:"",
      c:0,
      l:[]
    };
    // üÜï Normalizza lo stato iniziale
    state = normalizeState(state);
    let operatorName = loadOperatorName() || "";
    let lastPayloadText=""; // Variabile riposizionata

    // LOGIN
    document.addEventListener('DOMContentLoaded', ()=>{
      const loginBtn = document.getElementById('loginBtn');
      const loginNameInput = document.getElementById('loginNameInput');

      loginBtn.addEventListener('click', ()=>{
        const name = loginNameInput.value.trim();
        if(!name){
          alert("Inserisci un nome.");
          return;
        }
        operatorName = name;
        saveOperatorName(operatorName);
        updateOperatorLabel();
        showLoginOverlay(false);
      });
      
      // ‚¨áÔ∏è ENTER per inviare
      loginNameInput.addEventListener('keydown', (e)=>{
        if(e.key === 'Enter'){
          e.preventDefault();
          loginBtn.click();
        }
      });

      if(operatorName){
        updateOperatorLabel();
        showLoginOverlay(false);
      }else{
        showLoginOverlay(true);
      }
    });

    function showLoginOverlay(show){
      const ov=document.getElementById('loginOverlay');
      ov.style.display = show ? 'flex':'none';
      // blocca lo scroll quando il login √® visibile
      document.documentElement.style.overflow = show ? 'hidden' : '';
      document.body.style.overflow = show ? 'hidden' : '';
    }

    function loadOperatorName(){
      try{
        return localStorage.getItem(KEY_OP) || "";
      }catch{
        return "";
      }
    }

    function saveOperatorName(n){
      try{
        localStorage.setItem(KEY_OP,n);
      }catch{}
    }

    function updateOperatorLabel(){
      const tag=document.getElementById('opNameTag');
      if(operatorName){
        tag.textContent = operatorName;
        tag.classList.remove('hidden');
      }else{
        tag.textContent = "";
        tag.classList.add('hidden');
      }
    }

    // ------- PATCH iOS 100vh reale -------
    function setVH(){
      document.documentElement.style.setProperty('--vh', (window.innerHeight * 0.01) + 'px');
    }
    window.addEventListener('resize', setVH);
    window.addEventListener('orientationchange', setVH);
    setVH();
    // -------------------------------------

    // BOOT
    ;(async()=>{
      setStatus("Carico runtime‚Ä¶");

      try {
          await loadScript(PYODIDE_URL);
          await Promise.all([
            loadScript(ZXING_URL),
            loadScript(JSQR_URL),
            loadScript(QRG_URL),
            loadScript(JSPDF_URL),
            loadScript(PDFJS_URL),
            loadScript(PDFJS_WORKER_URL)
          ]);

          pyodide = await loadPyodide({ indexURL:"https://cdn.jsdelivr.net/pyodide/v0.25.1/full/" });
          await initPython();
          await initDecoders();

          jsPDFmod = window.jspdf;
          pdfjsLib = window['pdfjs-dist/build/pdf'];
          if (pdfjsLib) {
            pdfjsLib.GlobalWorkerOptions.workerSrc = PDFJS_WORKER_URL;
          }

          setStatus("Pronto (offline dopo primo avvio).");
          applyMeta();
          renderTables();
          unlockButtons();

      } catch (e) {
          console.error("Errore critico durante il boot:", e);
          setStatus(`<span class="err">Errore critico all'avvio: ${e.message||'vedi console'}</span>`);
      }
    })();

    function unlockButtons(){
      document.getElementById('btnGenQR').disabled=false;
      document.getElementById('btnDownloadPNG').disabled=true;
      document.getElementById('btnPrint').disabled=true;
      document.getElementById('btnPDFMain').disabled=true;
    }

    function loadScript(src){
      return new Promise((res,rej)=>{
        const s=document.createElement('script');
        s.src=src;
        s.onload=res;
        s.onerror=rej;
        document.head.appendChild(s);
      });
    }

    function setStatus(t){
      document.getElementById('status').innerHTML=t;
    }

    async function initPython(){
      await pyodide.runPythonAsync(`
import json, zlib
_CH="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:"
_MAP={c:i for i,c in enumerate(_CH)}
def b45encode(data: bytes) -> str:
    out=[]; i=0; n=len(data)
    while i<n:
        if i+1<n:
            x=(data[i]<<8)|data[i+1]
            out.extend((_CH[x//(45*45)], _CH[(x//45)%45], _CH[x%45])); i+=2
        else:
            x=data[i]; out.extend((_CH[x//45], _CH[x%45])); i+=1
    return "".join(out)
def b45decode(s: str) -> bytes:
    buf=bytearray(); i=0; n=len(s)
    while i<n:
        if i+2<n:
            x=_MAP[s[i]]*45*45 + _MAP[s[i+1]]*45 + _MAP[s[i+2]]
            buf+=bytes([(x>>8)&0xFF, x&0xFF]); i+=3
        else:
            x=_MAP[s[i]]*45 + _MAP[s[i+1]]
            buf.append(x&0xFF); i+=2
    return bytes(buf)
SCHEME="QRJ1:"
def pack_json_str(s: str) -> str:
    comp=zlib.compress(s.encode("utf-8"),9)
    return SCHEME + b45encode(comp)
def unpack_to_pretty(s: str) -> str:
    if not s.startswith(SCHEME):
        raise ValueError("prefisso QRJ1: mancante")
    payload=s[len(SCHEME):]
    data=zlib.decompress(b45decode(payload)).decode("utf-8")
    obj=json.loads(data)
    return json.dumps(obj, ensure_ascii=False, indent=2)
      `);
    }

    async function initDecoders(){
      if('BarcodeDetector' in window){
        try{
          const fmts = await BarcodeDetector.getSupportedFormats?.()||[];
          if(fmts.includes('qr_code')||fmts.length){
            barcodeDetector=new BarcodeDetector({formats:['qr_code']});
          }
        }catch{}
      }
      zxingReader=new ZXing.BrowserMultiFormatReader();
    }

    // UTIL
    function today(){
      const d=new Date();
      return d.toISOString().slice(0,10);
    }

    function nowStamp(){
      const d = new Date();
      const yy=d.getFullYear();
      const mm=String(d.getMonth()+1).padStart(2,"0");
      const dd=String(d.getDate()).padStart(2,"0");
      const hh=String(d.getHours()).padStart(2,"0");
      const mi=String(d.getMinutes()).padStart(2,"0");
      return `${yy}-${mm}-${dd} ${hh}:${mi}`;
    }

    function loadLocal(){
      try{
        const s=localStorage.getItem(KEY_STORE);
        const obj=s?JSON.parse(s):null;
        if(!obj) return null;
        // üÜï La normalizzazione avviene dopo
        return obj;
      }catch{
        return null;
      }
    }

    function saveLocal(obj){
      try{
        localStorage.setItem(KEY_STORE, JSON.stringify(obj));
      }catch{}
    }
    
    // üÜï FUNZIONE DI NORMALIZZAZIONE DELLO STATO (CENTRALIZZATA)
    function normalizeState(obj){
      if(!obj || typeof obj !== 'object') {
        obj = { v:1, t:today(), l:[] };
      }
      obj.t = obj.t || today();
      obj.b = obj.b || "";
      obj.e = obj.e || "";
      obj.p = obj.p || "";
      obj.pos = obj.pos || "";
      obj.note = obj.note || "";
      obj.c = (typeof obj.c==="number"?obj.c:0);
      
      obj.l = (obj.l || []).map(it => ({
        d: it.d || "",
        q: it.q || 0,
        r: it.r || 0 // Assicura che 'r' sia sempre un numero
      }));
      return obj;
    }

    function escapeHtml(s){
      return s.replace(/[&<>"]/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c]));
    }

    function canonicalJSON(obj, includeRientro){
      // üÜï Usa lo stato normalizzato per generare il JSON canonico
      const normalizedObj = normalizeState(obj);

      const o = {
        v:normalizedObj.v,
        t: normalizedObj.t,
        b: normalizedObj.b,
        e: normalizedObj.e,
        o: operatorName || "",
        p: normalizedObj.p,
        pos: normalizedObj.pos,
        note: normalizedObj.note,
        c: normalizedObj.c,
        l: (normalizedObj.l||[]).map(x=>({
          d:x.d,
          q:x.q,
          r:(includeRientro ? (x.r||0) : 0)
        }))
      };

      return JSON.stringify(o,(k,v)=>{
        if(Array.isArray(v)) return v;
        if(v && typeof v==='object'){
          const out={};
          Object.keys(v).sort().forEach(k=>out[k]=v[k]);
          return out;
        }
        return v;
      });
    }

    async function sha256hex(s){
      const buf=new TextEncoder().encode(s);
      const h=await crypto.subtle.digest('SHA-256', buf);
      return [...new Uint8Array(h)].map(b=>b.toString(16).padStart(2,'0')).join('');
    }

    function dataURLtoBlob(dataURL){
      const b=atob(dataURL.split(',')[1]);
      const len=b.length;
      const u8=new Uint8Array(len);
      for(let i=0;i<len;i++) u8[i]=b.charCodeAt(i);
      return new Blob([u8],{type:'image/png'});
    }

    function downloadBlob(blob, name){
      const a=document.createElement('a');
      a.href=URL.createObjectURL(blob);
      a.download=name;
      a.click();
      setTimeout(()=>URL.revokeObjectURL(a.href), 4000);
    }

    function colorFromIndex(i){
      switch(i){
        case 0: return [220,38,38];
        case 1: return [245,158,11];
        case 2: return [250,204,21];
        case 3: return [16,185,129];
        case 4: return [59,130,246];
        case 5: return [139,92,246];
        case 6: return [255,255,255];
        default:return [255,255,255];
      }
    }

    function colorNameFromIndex(i){
      switch(i){
        case 0: return "ROSSO";
        case 1: return "ARANCIONE";
        case 2: return "GIALLO";
        case 3: return "VERDE";
        case 4: return "BLU";
        case 5: return "VIOLA";
        case 6: return "BIANCO / NESSUNO";
        default: return "BIANCO / NESSUNO";
      }
    }

    function slugify(s){
      return (s || "")
        .trim()
        .replace(/\s+/g,"_")
        .replace(/[^A-Za-z0-9_\-]+/g,"");
    }

    // NAV
    document.querySelectorAll('nav button[data-tab]').forEach(b=>{
      b.onclick=()=>goTab(b.dataset.tab,true);
    });
    document.querySelectorAll('[data-go]').forEach(el=>{
      el.onclick=()=>goTab(el.getAttribute('data-go'),true);
    });

    function goTab(id,fromUser=false){
      document.querySelectorAll('nav button').forEach(x=>x.classList.remove('active'));
      const nb=[...document.querySelectorAll('nav button[data-tab]')].find(b=>b.dataset.tab===id);
      if(nb) nb.classList.add('active');
      document.querySelectorAll('.tab').forEach(t=>t.classList.add('hidden'));
      document.getElementById(id).classList.remove('hidden');
      if(fromUser) {
          window.scrollTo({top:0,behavior:'smooth'});
          haptic('light'); // üÜï Feedback aptico/visivo al cambio tab
      }
    }

    // META FIELDS
    const boxIdEl      = document.getElementById('boxId');
    const eventNameEl  = document.getElementById('eventName');
    const prodNameEl   = document.getElementById('prodName');
    const posNameEl    = document.getElementById('posName');
    const noteFieldEl  = document.getElementById('noteField');
    const colorSelEl   = document.getElementById('colorSel');

    boxIdEl.value     = state.b || "";
    eventNameEl.value = state.e || "";

    function syncMeta(){
      state.b = boxIdEl.value.trim();
      state.e = eventNameEl.value.trim();
      state.p = prodNameEl.value.trim();
      state.pos = posNameEl.value.trim();
      state.note = noteFieldEl.value.trim();
      state.c = parseInt(colorSelEl.value||"0",10);
      state.t = state.t || today();
    }

    function applyMeta(){
      boxIdEl.value     = state.b || "";
      eventNameEl.value = state.e || "";
      prodNameEl.value  = state.p || "";
      posNameEl.value   = state.pos || "";
      noteFieldEl.value = state.note || "";
      colorSelEl.value  = (typeof state.c==="number"?state.c:0);
    }

    // LISTA HANDLERS
    document.getElementById('addItem').onclick=()=>{
      const d=document.getElementById('desc').value.trim();
      const q=parseInt(document.getElementById('qty').value||"0",10);
      if(!d || q<=0){
        alert("Inserisci descrizione e quantit√† > 0");
        return;
      }
      // üÜï Normalizza solo per sicurezza, ma lo stato dovrebbe essere gi√† pulito
      state = normalizeState(state);
      state.l.push({d,q,r:0});
      document.getElementById('desc').value="";
      document.getElementById('qty').value="1";
      renderTables();
      haptic('tick'); // üÜï Feedback aptico/visivo all'aggiunta
    };

    document.getElementById('saveLocal').onclick=()=>{
      syncMeta();
      // üÜï Normalizza prima di salvare
      state = normalizeState(state);
      saveLocal(state);
      alert("Salvato in locale.");
      haptic('light'); // üÜï Feedback aptico/visivo al salvataggio
    };

    document.getElementById('loadLocal').onclick=()=>{
      const s=loadLocal();
      if(s){
        // üÜï Normalizza lo stato caricato
        state = normalizeState(s);
        applyMeta();
        renderTables();
        updateProgress();
        saveLocal(state);
        haptic('light'); // üÜï Feedback aptico/visivo al caricamento
      } else {
        alert("Nessun dato locale.");
      }
    };

    document.getElementById('clearList').onclick=()=>{
      if(confirm("Svuotare la lista?")){
        state.l=[];
        // üÜï Normalizza lo stato dopo l'azzeramento
        state = normalizeState(state);
        renderTables();
        haptic('reset'); // üÜï Feedback aptico/visivo all'azzeramento
      }
    };

    document.getElementById('exportJson').onclick=()=>{
      syncMeta();
      // üÜï Normalizza lo stato prima di esportare
      state = normalizeState(state);
      const j = canonicalJSON(state,true);
      downloadBlob(new Blob([j],{type:'application/json'}),'lista.json');
    };

    function renderTables(){
      // tabella lista articoli
      const tb=document.querySelector('#itemsTbl tbody');
      tb.innerHTML="";
      state.l.forEach((it,idx)=>{
        const tr=document.createElement('tr');
        tr.innerHTML=`
          <td data-label="#" style="display:none">${idx+1}</td>
          <td data-label="Descrizione">${escapeHtml(it.d)}</td>
          <td data-label="Q.t√†">${it.q}</td>
          <td class="noprint" data-label="Azioni">
            <button class="btn sm ghost" data-del="${idx}">Elimina</button>
          </td>`;
        tb.appendChild(tr);
      });
      tb.querySelectorAll('button[data-del]').forEach(b=>{
        b.onclick=()=>{
          const i=parseInt(b.dataset.del,10);
          state.l.splice(i,1);
          renderTables();
          haptic('tock'); // üÜï Feedback aptico/visivo all'eliminazione
        };
      });

      // tabella rientro
      renderRientroTable();
    }

    // QR & PDF buttons
    const btnGenQR        = document.getElementById('btnGenQR');
    const btnDownloadPNG  = document.getElementById('btnDownloadPNG');
    const btnPrint        = document.getElementById('btnPrint');
    const btnPDFMain      = document.getElementById('btnPDFMain');

    btnGenQR.onclick = async ()=>{
      if(!pyodide){
        alert("Runtime non pronto, ricarica la pagina.");
        return;
      }
      syncMeta();
      // üÜï Normalizza lo stato prima di generare
      state = normalizeState(state);
      haptic('light'); // üÜï Feedback aptico/visivo all'inizio generazione

      if(!state.b || !state.e){
        alert("Compila ID baule ed Evento.");
        return;
      }

      const canon = canonicalJSON(state,true);
      document.getElementById('jsonCanon').value = canon;
      document.getElementById('sha256').textContent = await sha256hex(canon);

      let packed;
      try{
        packed = await pyodide.runPythonAsync(
          `pack_json_str(${JSON.stringify(canon)})`
        );
      }catch(e){
        alert("Errore pack Python: "+e);
        return;
      }
      lastPayloadText = packed;

      const border = 4;
      currentQRCanvas = makeQrCanvas(lastPayloadText, border);

      const box=document.getElementById('qrBox');
      box.innerHTML="";
      box.appendChild(currentQRCanvas);

      document.getElementById('encInfo').textContent =
        `ECC=H. Quiet zone ${border} moduli.`;

      btnDownloadPNG.disabled=false;
      btnPrint.disabled=false;
      btnPDFMain.disabled=false;
    };

    btnDownloadPNG.onclick=()=>{
      if(!currentQRCanvas) return;
      const DPI=300;
      const qrSizeMm = 80;
      const px=Math.round((qrSizeMm/25.4)*DPI);
      const out=document.createElement('canvas');
      out.width=px;
      out.height=px;
      const g=out.getContext('2d');
      g.imageSmoothingEnabled=false;
      g.fillStyle='#fff';
      g.fillRect(0,0,px,px);
      g.drawImage(currentQRCanvas,0,0,px,px);
      downloadBlob(dataURLtoBlob(out.toDataURL('image/png')), 'qr_baule.png');
      haptic('light');
    };

    btnPrint.onclick=()=>{
      generateAndHandlePDF("etichetta","print");
      haptic('light');
    };

    btnPDFMain.onclick=()=>{
      generateAndHandlePDF("etichetta","download");
      haptic('light');
    };

    document.getElementById('rPDF').onclick=()=>{
      generateAndHandlePDF("rientro","download");
      haptic('light');
    };

    function makeQrCanvas(text, borderMods){
      const typeNumber=0;
      const qr = qrcode(typeNumber, 'H');
      qr.addData(text);
      qr.make();

      const m=qr.getModuleCount();
      const mp=m+borderMods*2;
      const px=Math.max(512, mp*10);
      const c=document.createElement('canvas');
      c.width=px;
      c.height=px;
      const g=c.getContext('2d');
      g.imageSmoothingEnabled=false;
      g.fillStyle='#fff';
      g.fillRect(0,0,px,px);
      const s=px/mp;
      g.fillStyle='#000';
      for(let r=0;r<m;r++){
        for(let col=0;col<m;col++){
          if(qr.isDark(r,col)){
            g.fillRect(
              Math.round((col+borderMods)*s),
              Math.round((r+borderMods)*s),
              Math.ceil(s),
              Math.ceil(s)
            );
          }
        }
      }
      return c;
    }

    // === PDF (omesso: identico alla tua versione, tranne fix minori dove servono) ===
    // üóëÔ∏è Rimuovi `ensureRientroStore` qui e lascia solo `normalizeState`
    
    function generateAndHandlePDF(mode, action){
      // unified font sizes for tables
      const FONT_HEADER = 12;
      const FONT_CELL = 12;
      const TABLE_LINE = 0.35;   // spessore unico per tutti i bordi tabella


      if(!jsPDFmod || !pyodide){
        alert("Runtime non pronto, ricarica la pagina.");
        return;
      }
      
      // üÜï Normalizza lo stato prima di creare il PDF
      state = normalizeState(state);
      syncMeta();

      const { jsPDF } = jsPDFmod;
      const doc = new jsPDF({
        orientation:"landscape",
        unit:"mm",
        format:"a4"
      });

      // ‚úÖ Stato del watermark: lettura checkbox (solo PDF / stampa)
      const watermarkToggleEl = document.getElementById("watermarkToggle");
      const watermarkEnabled = watermarkToggleEl && watermarkToggleEl.checked;
      const watermarkText = (state.note || "").trim();

      let incompleto = false;
      state.l.forEach(it=>{
        if ((it.r||0) < it.q) incompleto=true;
      });

      const marginL = 15;
      const marginT = 20;
      const pageW   = 297;
      const pageH   = 210;
      // spazio extra per il footer fuori dal bordo
      const FRAME_INSET = 8;      // distanza dai lati
      const FOOTER_AREA = 12;     // altezza riservata al footer fuori dal bordo
      function drawPageFrame(d){
        d.setDrawColor(0,0,0);        // NERO
        d.setLineWidth(0.6);
        // altezza ridotta per non toccare il footer esterno
        d.roundedRect(
          FRAME_INSET,
          FRAME_INSET,
          pageW - 2*FRAME_INSET,
          pageH - 2*FRAME_INSET - FOOTER_AREA,
          6, 6, "S"
        );
      }
      drawPageFrame(doc);
      
      // ‚úÖ Watermark sulla PRIMA pagina (dietro a tutto il resto)
      if (mode === "etichetta" && watermarkEnabled && watermarkText){
        drawDiagonalWatermark(doc, watermarkText);
      }
      
      // ‚úÖ Watermark diagonale dalla NOTA (centrato, lungo la diagonale A4 landscape)
      // ‚úÖ Watermark diagonale multiriga, centrato sul centro geometrico pagina
      function drawDiagonalWatermark(doc, text){
        if (!text) return;

        // Angolo reale della diagonale A4 orizzontale
        const angleRad = Math.atan(pageH / pageW);
        const angleDeg = angleRad * 180 / Math.PI;

        // Centro pagina
        const centerX = pageW / 2;
        const centerY = pageH / 2;

        // Max larghezza blocco (rispetta i margini interni al frame)
        const usableW = (pageW - 2*FRAME_INSET) * 0.80; // 80% del frame per stare leggeri
        const lines = doc.splitTextToSize(text.toString(), usableW);

        // misura blocco testo (in ‚Äúmm testo‚Äù, coerente con lineHeightFactor)
        const dims = doc.getTextDimensions(lines);
        const blockH = dims.h;

        // Compensazione: sposta l'ancora verso l'alto lungo la direzione di crescita delle righe
        // cos√¨ che il CENTRO del blocco coincida con (centerX, centerY).
        const half = blockH / 2;
        const anchorX = centerX - Math.sin(angleRad) * half;
        const anchorY = centerY - Math.cos(angleRad) * half;

        if (doc.saveGraphicsState) doc.saveGraphicsState();

        doc.setFont("helvetica", "bold");
        doc.setFontSize(40);
        doc.setTextColor(210,210,210);

        // baseline 'top': l'array di linee parte dall'ancora e cresce nella direzione ruotata
        doc.text(lines, anchorX, anchorY, {
          angle: angleDeg,
          align: "center",
          baseline: "top"
        });

        // ripristino
        doc.setTextColor(0,0,0);
        if (doc.restoreGraphicsState) doc.restoreGraphicsState();
      }


      function addFooter(d){
        d.setFont("helvetica","bold");      // pi√π marcato
        d.setFontSize(11);                  // leggermente pi√π grande
        d.setTextColor(30,30,30);           // pi√π scuro, quindi pi√π leggibile

        const footerText = "Show Technologies‚Ñ¢ ¬∑ info@showtechnologies.it ¬∑ +39 (0)185 720185";
        const textW = d.getTextWidth(footerText);
        const x = (pageW - textW)/2;
        const y = pageH - 10;               // un filo pi√π in alto per respirare

        d.text(footerText, x, y);
        d.setTextColor(0,0,0);              // reset colore testo
      }

      let curY = marginT;
      if (mode === "rientro"){
        if (incompleto){
          doc.setFont("helvetica","bold");
          doc.setFontSize(32);
          doc.setTextColor(255,0,0);
          doc.text("INCOMPLETO", marginL, curY);
        } else {
          doc.setFont("helvetica","bold");
          doc.setFontSize(24);
          doc.setTextColor(16,185,129);
          doc.text("TUTTO RIENTRATO", marginL, curY);
        }
        doc.setTextColor(0,0,0);
        curY += 14;
      }

      doc.setFont("helvetica","normal");
      doc.setFontSize(FONT_CELL);

                                   const tableX = marginL;
                                   const tableY = curY;
                                   const labelW = 35;
                                   const valueW = 100;
                                   const radius = 2.0;
                                   const metaPaddingTop = 4;   // padding top testo dentro la riga
                                   const metaSidePad    = 2;   // padding laterale

                                   const rowsMeta = [
                                     ["Operatore:", operatorName || ""],
                                     ["Evento:",    state.e || ""],
                                     ["Produzione:", state.p || ""],
                                     ["ID Baule:",   state.b || ""],
                                     ["Note:",       state.note || ""],
                                     ["Stampato:",   nowStamp()]
                                   ];

                                   const metaTableW = labelW + valueW;

                                   // 1) misura linee per ogni riga (label e valore)
                                   const measured = rowsMeta.map(([lab,val])=>{
                                     const labLines = doc.splitTextToSize(lab, labelW - metaSidePad*2);
                                     const valLines = doc.splitTextToSize(val || "", valueW - metaSidePad*2);
                                     // altezza blocco con getTextDimensions (coerente con lineHeightFactor del doc)
                                     const labH = doc.getTextDimensions(labLines).h;
                                     const valH = doc.getTextDimensions(valLines).h;
                                     // riga = max(label, value) + padding top/bottom (qui usiamo top + 2mm extra)
                                     // riga = max(label, value) + padding extra pi√π generoso
                                     const rowH = Math.max(labH, valH) + metaPaddingTop + 2;                                     return { labLines, valLines, rowH };
                                   });

                                   // 2) altezza totale tabella
                                   const metaTableH = measured.reduce((acc,m)=>acc + m.rowH, 0);

                                   // 3) cornice esterna
                                   doc.setDrawColor(0,0,0);
                                   doc.setLineWidth(TABLE_LINE);
                                   doc.roundedRect(tableX, tableY, metaTableW, metaTableH, radius, radius, "S");

                                   // 4) separatori orizzontali + separatore verticale label/valore
                                   let yCursorMeta = tableY;
                                   for (let i=0;i<measured.length;i++){
                                     yCursorMeta += measured[i].rowH;
                                     if (i < measured.length-1){
                                       doc.line(tableX, yCursorMeta, tableX + metaTableW, yCursorMeta);
                                     }
                                   }
                                   doc.line(tableX+labelW, tableY, tableX+labelW, tableY+metaTableH);

                                   // 5) stampa testi (verticalmente centrati dentro ogni riga)
                                   yCursorMeta = tableY;
                                   for (let i = 0; i < measured.length; i++) {
                                     const { labLines, valLines, rowH } = measured[i];

                                     // LABEL
                                     const labIsSingle = labLines.length === 1;
                                     let yLab;
                                     if (labIsSingle) {
                                       const labH = doc.getTextDimensions(labLines[0]).h;
                                       const centerRow = yCursorMeta + rowH / 2;
                                       yLab = centerRow + labH / 2 - 1;
                                     } else {
                                       const labH = doc.getTextDimensions(labLines).h;
                                       yLab = yCursorMeta + (rowH - labH) / 2;
                                     }

                                     // VALORE
                                     const valIsSingle = valLines.length === 1;
                                     let yVal;
                                     if (valIsSingle) {
                                       const valH = doc.getTextDimensions(valLines[0]).h;
                                       const centerRow = yCursorMeta + rowH / 2;
                                       yVal = centerRow + valH / 2 - 1;
                                     } else {
                                       const valH = doc.getTextDimensions(valLines).h;
                                       yVal = yCursorMeta + (rowH - valH) / 2;
                                     }

                                     doc.text(labLines, tableX + metaSidePad, yLab);
                                     doc.text(valLines, tableX + labelW + metaSidePad, yVal);

                                     yCursorMeta += rowH;
                                   }

      const qrSizeMm = 80;
      const qrX = pageW - qrSizeMm - 20;
      // Offset per abbassare il QR rispetto al margine superiore pagina
      const QR_TOP_OFFSET = 12;               // ‚Üë aumenta per scendere
      const qrY = marginT + QR_TOP_OFFSET;
      const GAP_AROUND_QR = 12;     // distanza identica sopra/sotto il QR

      const canon = canonicalJSON(state,true);

      pyodide.runPythonAsync(
        `pack_json_str(${JSON.stringify(canon)})`
      ).then(qp=>{
        const qrCanvas = makeQrCanvas(qp, 4);
        const qrDataURL = qrCanvas.toDataURL("image/png");

        const rgb = colorFromIndex(state.c || 0);
        doc.setDrawColor(rgb[0], rgb[1], rgb[2]);
        doc.setLineWidth(3);
        const pad=4;
        doc.roundedRect(
          qrX - pad/2,
          qrY - pad/2,
          qrSizeMm + pad,
          qrSizeMm + pad,
          3,3,"S"
        );

        doc.addImage(qrDataURL, "PNG", qrX, qrY, qrSizeMm, qrSizeMm);

        // POSIZIONE sopra al QR (stile come etichetta colore)
        if ((state.pos || "").trim()) {
          doc.setFont("helvetica","bold");
          doc.setFontSize(20);
          const posText = state.pos.trim();
          // equidistante: stessa distanza dal bordo superiore del QR
          const desiredPosY = qrY - GAP_AROUND_QR;
          const topSafe = marginT + 6;              // per non attaccarsi al bordo pagina
          const posY = Math.max(topSafe, desiredPosY);
          doc.text(posText, qrX + qrSizeMm/2, posY, { align: "center" });
        }
            // COLOR LABEL BELOW QR
        const colorLabel = colorNameFromIndex(state.c || 0);
        doc.setFont("helvetica","bold");
        doc.setFontSize(20);
        doc.setTextColor(0,0,0);
        // center under QR
        const COLOR_BELOW_QR = 14; // ‚Üë aumenta per scendere
        const colorY = qrY + qrSizeMm + GAP_AROUND_QR;   // stessa distanza del testo sopra
        doc.text(colorLabel, qrX + qrSizeMm/2, colorY, { align: "center" });

        const maxRightBeforeQR = qrX - 10;
        const matStartY = tableY + metaTableH + 8;

        drawMaterialsTable(doc, {
          startY: matStartY,
          leftX: marginL,
          maxRight: maxRightBeforeQR,
          mode: mode,
          marginT: marginT,
          pageW: pageW,
          pageH: pageH,
          addFooterFn: addFooter
        });

        addFooter(doc);
        
        /* üî¢ NUMERAZIONE PAGINE 1/n IN BASSO A DESTRA (solo se multipagina) */
        const pageCount = doc.getNumberOfPages();
        if (pageCount > 1){
          for (let i = 1; i <= pageCount; i++){
            doc.setPage(i);
            doc.setFont("helvetica","bold");
            doc.setFontSize(11);
            doc.setTextColor(0,0,0);

            const label = `${i}/${pageCount}`;
            const textW = doc.getTextWidth(label);
            const x = pageW - FRAME_INSET - textW - 2; // vicino al bordo destro
            const y = pageH - 8;                       // stessa altezza del footer

            doc.text(label, x, y);
          }
        }
        /* fine numerazione */

        /* üì± Mini QR dell'app in basso a destra, discreto */
        try{
          // riuso il generatore QR gi√† esistente
          const miniQrCanvas = makeQrCanvas(APP_URL, 1); // bordo 1 modulo
          const miniQrDataURL = miniQrCanvas.toDataURL("image/png");

          const miniSize = 18; // mm, piccolo/discreto
          const miniX = pageW - FRAME_INSET - miniSize - 4; // 4 mm di margine dal bordo destro interno
          const miniY = pageH - FRAME_INSET - FOOTER_AREA - miniSize - 4; // sopra il footer, dentro al frame

          for (let i = 1; i <= pageCount; i++){
            doc.setPage(i);
            doc.addImage(miniQrDataURL, "PNG", miniX, miniY, miniSize, miniSize);
          }
        }catch(e){
          console.warn("Mini QR app non generato:", e);
        }
        /* fine mini QR */

        const baseName =
          slugify(state.p || state.e || "Evento") + "_" +
          slugify(state.b || "Baule") +
          (mode==="rientro" ? "_RIENTRO" : "");

        if(action === "download"){
          doc.save(baseName + ".pdf");
        }else{
          const blobUrl = doc.output("bloburl");
          window.open(blobUrl, "_blank");
        }
      });

      function drawMaterialsTable(doc, cfg){
        let yCursor = cfg.startY;

        doc.setFont("helvetica","bold");
        doc.setFontSize(16);
        if (cfg.mode === "rientro"){
          doc.text("DISTINTA RIENTRO", cfg.leftX, yCursor);
        } else {
          doc.text("DISTINTA", cfg.leftX, yCursor);
        }
        yCursor += 8;
        const availableW = Math.max(60, (cfg.maxRight - cfg.leftX));

        // Rientro (4 col) e Normale (2 col) con stessa larghezza totale
        const ratiosRientro = [0.68, 0.10, 0.12, 0.10]; // Descr, Prev, Rientrati, Manca
        const ratiosNormale = [0.82, 0.18];             // Descr, Q.t√†

        let headers, colWidths;

        if (cfg.mode === "rientro"){
          headers   = ["Descrizione","Q.t√†","IN","OUT"];
          colWidths = ratiosRientro.map(r => Math.round(r * availableW));
        } else {
          headers   = ["Descrizione","Q.t√†"];
          colWidths = ratiosNormale.map(r => Math.round(r * availableW));
        }

        // correzione arrotondamenti per sommare esattamente availableW
        {
          const sumW = colWidths.reduce((a,b)=>a+b,0);
          let diff = availableW - sumW;
          let k = 0;
          while (diff !== 0 && k < 50){
            const idx = k % colWidths.length;
            if (diff > 0) colWidths[idx] += 1;
            else if (diff < 0 && colWidths[idx] > 1) colWidths[idx] -= 1;
            k++;
            const ssum = colWidths.reduce((a,b)=>a+b,0);
            diff = availableW - ssum;
          }
        }

        const finalTableW = colWidths.reduce((a,b)=>a+b,0);
        // linee: usiamo il motore di jsPDF (coerente con splitTextToSize)
        const baseLineH = 8;

        // header multiriga (wrap su ogni colonna)
        const headerLines = headers.map((h, idx)=>{
          const usableW = Math.max(6, colWidths[idx] - 4); // 2mm padding per lato
          return doc.splitTextToSize(h, usableW);
        });
        const headerH = Math.max(...headerLines.map(ls => doc.getTextDimensions(ls).h)) + 6; // + padding extra
        function buildRowObjects(){
          const rowsOut=[];

          rowsOut.push({
            type:"header",
            cells: headerLines,   // << array di linee per ogni cella header
            h: headerH,
            descLines: null
          });

          state.l.forEach(it=>{
            const prev = it.q;
            const rin  = it.r || 0;
            const manc = Math.max(0, prev - rin);

            const descCell = it.d || "";
            const descLines = doc.splitTextToSize(descCell, colWidths[0] - 4);

            // prepara array di celle in base alla modalit√†
            let rawCells;
            if (cfg.mode === "rientro"){
              rawCells = [
                descLines,                 // col 0 (array gi√† avvolto)
                String(prev),
                String(rin),
                String(manc)
              ];
            } else {
              rawCells = [
                descLines,
                String(prev)
              ];
            }

            // avvolgi anche le colonne NON descrizione
            const cellsWrapped = rawCells.map((val, idx)=>{
              if (Array.isArray(val)) return val; // descrizione gi√† ok
              const usableW = Math.max(6, colWidths[idx] - 4);
              return doc.splitTextToSize(String(val||""), usableW);
            });

            // altezza riga = max altezza tra tutte le celle + padding
            const cellHeights = cellsWrapped.map(ls => doc.getTextDimensions(ls).h);
            // +10 mm rispetto al blocco testo ‚Üí pi√π aria sopra/sotto
            const rowH = Math.max(baseLineH, Math.max(...cellHeights) + 4);

            const cells = cellsWrapped;

            rowsOut.push({
              type:"data",
              cells,
              h: rowH,
              descLines
            });
          });

          return rowsOut;
        }

        const allRows = buildRowObjects();

        function drawTablePage(rowIndex, startY){
          let yTopTable = startY;
          let curRow = rowIndex;

          let rowsThisPage = [];
          let totalH = 0;
          for(let i=curRow;i<allRows.length;i++){
            const h = allRows[i].h;
            if (yTopTable + totalH + h + 20 > cfg.pageH){
              break;
            }
            rowsThisPage.push(allRows[i]);
            totalH += h;
          }

          if(rowsThisPage.length===0 && curRow<allRows.length){
            rowsThisPage.push(allRows[curRow]);
            totalH += allRows[curRow].h;
          }

          const radiusOuter = 2.0;
          doc.setDrawColor(0,0,0);
          doc.setLineWidth(TABLE_LINE);
          doc.roundedRect(
            cfg.leftX,
            yTopTable,
            finalTableW,
            totalH,
            radiusOuter,
            radiusOuter,
            "S"
          );

          let xCursor = cfg.leftX;
          for(let c=0;c<colWidths.length-1;c++){
            xCursor += colWidths[c];
            doc.line(
              xCursor,
              yTopTable,
              xCursor,
              yTopTable+totalH
            );
          }

          let drawY = yTopTable;
          for(let r=0;r<rowsThisPage.length;r++){
            const row = rowsThisPage[r];

            if(row.type==="header"){
              doc.setFont("helvetica","bold");
              doc.setFontSize(FONT_HEADER);
            }else{
              doc.setFont("helvetica","normal");
              doc.setFontSize(FONT_CELL);
            }

            let cellX = cfg.leftX;
            for (let c = 0; c < colWidths.length; c++) {
              const cellW = colWidths[c];
              const lines = Array.isArray(row.cells[c])
                ? row.cells[c]
                : [String(row.cells[c] || "")];

              const isSingleLine = lines.length === 1;

              let textY;

              if (isSingleLine) {
                // üîπ Caso UNA SOLA RIGA
                // Simuliamo il comportamento "vecchio stile":
                // - calcoliamo l'altezza della riga di testo
                // - la posizioniamo leggermente sotto il centro,
                //   come faceva il tuo offset fisso (tipo drawY+6 su rowH=8)
                const lineH = doc.getTextDimensions(lines[0]).h;

                const centerRow = drawY + row.h / 2;
                // baseline = centro riga + met√† altezza font - piccola correzione
                textY = centerRow + lineH / 2 - 1; // se vuoi pi√π centrato, prova -0.5 o -0.8
              } else {
                // üîπ Caso MULTIRIGA
                // Usando il blocco completo, centrato geometricamente
                const blockH = doc.getTextDimensions(lines).h;
                textY = drawY + (row.h - blockH) / 2;
              }

              lines.forEach(line => {
                doc.text(line, cellX + 2, textY);
                textY += doc.getTextDimensions(line).h;
              });

              cellX += cellW;
            }

            const rowH = row.h;
            drawY += rowH;
            if(r < rowsThisPage.length-1){
              doc.line(
                cfg.leftX,
                drawY,
                cfg.leftX+finalTableW,
                drawY
              );
            }
          }

          return {
            nextRowIndex: curRow + rowsThisPage.length,
            nextY: drawY
          };
        }

        let rowIdx = 0;
        let localY = yCursor;

        while(rowIdx < allRows.length){
          const res = drawTablePage(rowIdx, localY);
          rowIdx = res.nextRowIndex;
          localY = res.nextY;

          if(rowIdx < allRows.length){
            cfg.addFooterFn(doc);
            doc.addPage("a4","landscape");
            drawPageFrame(doc);

            // ‚úÖ Watermark anche sulle PAGINE SUCCESSIVE (sempre dietro la tabella)
            if (cfg.mode === "etichetta" && watermarkEnabled && watermarkText){
              drawDiagonalWatermark(doc, watermarkText);
            }

            localY = cfg.marginT;
            doc.setFont("helvetica","bold");
            doc.setFontSize(16);
            if (cfg.mode === "rientro"){
              doc.text("DISTINTA RIENTRO", cfg.leftX, localY);
            } else {
              doc.text("DISTINTA", cfg.leftX, localY);
            }
            localY += 8;
          }
        }
      }
    }

    // DECODE / SCAN
    const decStatus=document.getElementById('decStatus'),
          rawOut=document.getElementById('rawOut');
    const jsonDecoded=document.getElementById('jsonDecoded'),
          btnSetCurrent=document.getElementById('btnSetCurrent'),
          btnCompare=document.getElementById('btnCompare'),
          cmpResult=document.getElementById('cmpResult');

    document.getElementById('fileInput').addEventListener('change', async ev=>{
      const f=ev.target.files?.[0];
      if(!f) return;
      decStatus.textContent="Decodifica‚Ä¶";

      if (f.type === "application/pdf") {
        try{
          const text = await decodeFromPDF(f);
          await handleDecodedText(text);
        }catch(e){
          decStatus.innerHTML=`<span class="err">${e}</span>`;
        }
      } else {
        const url=URL.createObjectURL(f);
        try{
          const img=new Image();
          await new Promise(r=>{ img.onload=r; img.src=url; });
          const text=await robustDecodeFromImage(img);
          URL.revokeObjectURL(url);
          await handleDecodedText(text);
        }catch(e){
          URL.revokeObjectURL(url);
          decStatus.innerHTML=`<span class="err">${e}</span>`;
        }
      }
    });

    document.getElementById('cameraShot').addEventListener('change', async ev=>{
      const f=ev.target.files?.[0];
      if(!f) return;
      decStatus.textContent="Decodifica foto‚Ä¶";

      const url=URL.createObjectURL(f);
      try{
        const img=new Image();
        await new Promise(r=>{ img.onload=r; img.src=url; });
        const text=await robustDecodeFromImage(img);
        URL.revokeObjectURL(url);
        await handleDecodedText(text);
      }catch(e){
        URL.revokeObjectURL(url);
        decStatus.innerHTML=`<span class="err">${e}</span>`;
      }
    });

    const camOverlay   = document.getElementById('cameraOverlay');
    const camVideo     = document.getElementById('cameraVideo');
    const camCanvas    = document.getElementById('cameraCanvas');
    const camStatusEl  = document.getElementById('camStatus');
    const closeCamBtn  = document.getElementById('closeCamBtn');
    const toggleFlashBtn = document.getElementById('toggleFlashBtn');

    document.getElementById('btnCam').onclick = ()=>{
      startCameraOverlay();
    };
    closeCamBtn.onclick = ()=>{
      stopCameraOverlay("Chiuso.");
    };
    toggleFlashBtn.onclick = ()=>{
      toggleTorch();
    };

    // ------- PATCH start/stop camera -------
    async function startCameraOverlay(){
      camOverlay.style.display='flex';
      camStatusEl.textContent="Apertura camera‚Ä¶";
      torchEnabled=false;

      try{
        // primo tentativo: camera posteriore "exact"
        camStream = await navigator.mediaDevices.getUserMedia({
          video:{
            facingMode:{ exact:'environment' },
            width:{ ideal:1280 },
            height:{ ideal:720 },
            aspectRatio:{ ideal: window.innerWidth / window.innerHeight }
          },
          audio:false
        });
      }catch(e){
        // fallback: qualunque posteriore disponibile
        try{
          camStream = await navigator.mediaDevices.getUserMedia({
            video:{ facingMode:'environment' },
            audio:false
          });
        }catch(e2){
          camStatusEl.textContent="Webcam non disponibile.";
          return;
        }
      }

      camVideo.srcObject = camStream;

      // avvio esplicito per Safari/iOS
      try { await camVideo.play(); } catch {}

      camTrack = camStream.getVideoTracks()[0] || null;
      camScanning = true;

      let torchCapable=false;
      if (camTrack && camTrack.getCapabilities) {
        const caps = camTrack.getCapabilities();
        torchCapable = !!caps.torch;
      }
      toggleFlashBtn.disabled = !torchCapable;
      toggleFlashBtn.classList.toggle('hidden', !torchCapable);

      camStatusEl.textContent="Inquadra il QR‚Ä¶";
      tickLiveScan();
    }

    function stopCameraOverlay(msg){
      camScanning=false;
      if(camStream){
        camStream.getTracks().forEach(t=>t.stop());
        camStream=null;
      }
      camTrack=null;
      camOverlay.style.display='none';
      camStatusEl.textContent = msg || "";
      torchEnabled=false;
    }
    // ------- FINE PATCH -------

    async function toggleTorch(){
      if(!camTrack || !camTrack.applyConstraints) return;
      torchEnabled=!torchEnabled;
      try{
        await camTrack.applyConstraints({advanced:[{torch:torchEnabled}]});
        toggleFlashBtn.textContent = torchEnabled ? "Flash ON" : "Flash";
      }catch(e){
        camStatusEl.textContent="Flash non supportato.";
      }
    }

    async function tickLiveScan(){
      if(!camScanning || !camStream) return;

      if (camVideo.readyState === camVideo.HAVE_ENOUGH_DATA){
        camCanvas.width  = camVideo.videoWidth;
        camCanvas.height = camVideo.videoHeight;
        const gx = camCanvas.getContext('2d');
        gx.drawImage(camVideo,0,0,camCanvas.width,camCanvas.height);

        robustDecodeFromCanvas(camCanvas).then(async text=>{
          if (text && camScanning){
            camScanning=false;
            await handleDecodedText(text);
            camStatusEl.textContent="QR rilevato.";
            stopCameraOverlay("QR letto.");
            haptic('success'); // üÜï Feedback aptico/visivo al successo della scansione
          }
        });
      }

      if(camScanning){
        // üóëÔ∏è Rimuovi setTimeout per migliorare la fluidit√† (lascia solo rAF)
        requestAnimationFrame(tickLiveScan);
      }
    }

    async function handleDecodedText(text){
      if(!text){
        decStatus.innerHTML=`<span class="warn">Nessun QR leggibile.</span>`;
        rawOut.textContent="";
        jsonDecoded.value="";
        btnSetCurrent.disabled=true;
        btnCompare.disabled=true;
        return;
      }
      rawOut.textContent=text;
      try{
        const pretty=await pyodide.runPythonAsync(
          `unpack_to_pretty(${JSON.stringify(text)})`
        );
        jsonDecoded.value=pretty;
        decodedObj=JSON.parse(pretty);

        // üÜï Normalizza l'oggetto decodificato
        decodedObj = normalizeState(decodedObj);

        decStatus.innerHTML=`<span class="ok">QRJ1 decodificato.</span>`;
        btnSetCurrent.disabled=false;
        btnCompare.disabled=false;
      }catch{
        jsonDecoded.value="";
        decodedObj=null;
        decStatus.innerHTML=`<span class="warn">QR letto ma non QRJ1.</span>`;
        btnSetCurrent.disabled=true;
        btnCompare.disabled=true;
      }
    }

    btnSetCurrent.onclick=()=>{
      try{
        const obj=JSON.parse(jsonDecoded.value);

        // üÜï Normalizza l'oggetto da JSON ricostruito
        state = normalizeState(obj);
        
        applyMeta();
        renderTables();
        updateProgress();
        saveLocal(state);
        alert("Lista impostata come corrente.");
        haptic('light'); // üÜï Feedback aptico/visivo all'impostazione
      }catch(e){
        alert("JSON non valido.");
      }
    };

    btnCompare.onclick=async()=>{
      try{
        // üÜï Normalizza gli stati prima di confrontare
        const a = canonicalJSON(state,true);
        const b = canonicalJSON(JSON.parse(jsonDecoded.value),true);
        const equal = (await sha256hex(a)) === (await sha256hex(b));
        cmpResult.innerHTML = equal
          ? '<span class="ok">La lista coincide.</span>'
          : '<span class="warn">Le liste sono diverse.</span>';
          haptic(equal ? 'light' : 'tock'); // üÜï Feedback aptico/visivo al confronto
      }catch(e){
        cmpResult.innerHTML=`<span class="err">${e}</span>`;
        haptic('error'); // üÜï Feedback aptico/visivo all'errore
      }
    };

    // RIENTRO
    function renderRientroTable(){
      // üÜï Normalizza lo stato prima del rendering
      state = normalizeState(state);
      
      const tb=document.querySelector('#rTbl tbody');
      tb.innerHTML="";

      let totPrev=0, totR=0;
      state.l.forEach((it,idx)=>{
        totPrev+=it.q;
        const r=it.r||0;
        totR+=Math.min(it.q, r);
        const manca=Math.max(0, it.q - r);

        const tr=document.createElement('tr');
        // üÜï Aggiungo l'indice alla riga per la selezione diretta
        tr.setAttribute('data-i', idx);
        
        tr.innerHTML=`
          <td data-label="#" style="display:none">${idx+1}</td>
          <td data-label="Descrizione">${escapeHtml(it.d)}</td>
          
          <td data-label="Prev.">${it.q}</td>
          <td data-label="Manca" class="mancaCell">${manca}</td>
          
          <td class="rCtrl-wrap" style="display:none;" data-label="Controlli">
            <div class="rCtrl">
              <input class="rQtyInputBig" type="number" min="0" max="${it.q}" value="${r}" data-i="${idx}">
            </div>
          </td>
        `;
        tb.appendChild(tr);
      });

      // üÜï Nuovo: Gestore click per la selezione diretta della riga
      tb.querySelectorAll('tr').forEach(row => {
          row.addEventListener('click', () => {
              const i = parseInt(row.dataset.i, 10);
              openCounter(i);
          });
      });
      
      // input manuale con clamp
      tb.querySelectorAll('.rQtyInputBig').forEach(inp=>{
        inp.addEventListener('change', ()=>{
          const i = parseInt(inp.dataset.i,10);
          const it = state.l[i];
          if(!it) return;
          let v = parseInt(inp.value||"0",10);
          if(isNaN(v)) v=0;
          v = Math.max(0, Math.min(it.q, v));
          it.r = v;
          inp.value = String(v);
          saveLocal(state);
          updateProgress();
          const row = tb.children[i];
          if(row){
            // Assicura che la cella "Manca" visibile venga aggiornata (desktop e mobile)
            const mancaCell = row.querySelector('.mancaCell');
            if (mancaCell) mancaCell.textContent = String(Math.max(0, it.q - v));
          }
          haptic('light'); // üÜï Feedback aptico/visivo al cambio manuale
        });
      });

      document.getElementById('rInfo').textContent=`Totale previsti: ${totPrev}`;
      updateProgress();
    }
    function updateProgress(){
      // üÜï Normalizza lo stato prima del calcolo
      state = normalizeState(state);
      
      let totPrev=0, totR=0;
      state.l.forEach(it=>{
        totPrev+=it.q;
        totR+=Math.min(it.q, it.r||0);
      });
      const pct = totPrev>0 ? Math.round(100*totR/totPrev) : 0;
      const bar=document.getElementById('rBar');
      bar.style.width = pct+'%';
      document.getElementById('rPct').textContent =
        `${pct}% ‚Ä¢ ${totR}/${totPrev}`;
    }

    document.getElementById('rReset').onclick=()=>{
      // üÜï Normalizza lo stato prima di resettare
      state = normalizeState(state);
      
      state.l.forEach(it=>{it.r=0;});
      updateProgress();
      renderRientroTable();
      saveLocal(state);
      haptic('reset');
    };

    document.getElementById('rAll').onclick=()=>{
      // üÜï Normalizza lo stato prima di marcare
      state = normalizeState(state);
      
      state.l.forEach(it=>{it.r=it.q;});
      updateProgress();
      renderRientroTable();
      saveLocal(state);
      haptic('success');
    };

    document.getElementById('rExport').onclick=()=>{
      // üÜï Normalizza lo stato prima di esportare
      state = normalizeState(state);
      
      const rows=[
        ["ID baule", state.b],
        ["Evento", state.e],
        ["Operatore", operatorName || ""],
        ["Produzione", state.p || ""],
        ["Posizione", state.pos || ""],
        ["Note", state.note || ""],
        ["Report", nowStamp()],
        [],
        ["Descrizione","Prev","Rientrati","Manca"]
      ];
      state.l.forEach((it)=>{
        const manque=Math.max(0, it.q-(it.r||0));
        rows.push([it.d, it.q, it.r||0, manque]);
      });
      const csv=rows.map(r=>r.join(";")).join("\n");
      downloadBlob(new Blob([csv],{type:'text/csv'}), 'rientro.csv');
    };

    // QR decode helpers
    function drawToCanvas(img){
      const c=document.createElement('canvas');
      c.width=img.naturalWidth||img.videoWidth||img.width;
      c.height=img.naturalHeight||img.videoHeight||img.height;
      c.getContext('2d',{willReadFrequently:true}).drawImage(img,0,0,c.width,c.height);
      return c;
    }

    function toGray(c){
      const ctx=c.getContext('2d',{willReadFrequently:true});
      const d=ctx.getImageData(0,0,c.width,c.height);
      const a=d.data;
      for(let i=0;i<a.length;i+=4){
        const y=(a[i]*0.2126+a[i+1]*0.7152+a[i+2]*0.0722)|0;
        a[i]=a[i+1]=a[i+2]=y;
      }
      const out=document.createElement('canvas');
      out.width=c.width;
      out.height=c.height;
      out.getContext('2d').putImageData(d,0,0);
      return out;
    }

    function otsu(c){
      const ctx=c.getContext('2d',{willReadFrequently:true});
      const d=ctx.getImageData(0,0,c.width,c.height),
            a=d.data,
            hist=new Array(256).fill(0);

      for(let i=0;i<a.length;i+=4) hist[a[i]]++;

      const total=c.width*c.height;
      let sum=0;
      for(let t=0;t<256;t++) sum+=t*hist[t];
      let sumB=0,wB=0,varMax=0,th=128;
      for(let t=0;t<256;t++){
        wB+=hist[t];
        if(!wB) continue;
        const wF=total-wB;
        if(!wF) break;
        sumB+=t*hist[t];
        const mB=sumB/wB,mF=(sum-sumB)/wF;
        const between=wB*wF*(mB-mF)*(mB-mF);
        if(between>varMax){
          varMax=between;
          th=t;
        }
      }
      for(let i=0;i<a.length;i+=4){
        const v=a[i]<th?0:255;
        a[i]=a[i+1]=a[i+2]=v;
      }
      const out=document.createElement('canvas');
      out.width=c.width;
      out.height=c.height;
      out.getContext('2d').putImageData(d,0,0);
      return out;
    }

    function rotate(c,deg){
      const o=document.createElement('canvas'),
            g=o.getContext('2d');
      if(deg%180===0){
        o.width=c.width;
        o.height=c.height;
      }else{
        o.width=c.height;
        o.height=c.width;
      }
      g.translate(o.width/2,o.height/2);
      g.rotate(deg*Math.PI/180);
      g.imageSmoothingEnabled=false;
      g.drawImage(c,-c.width/2,-c.height/2);
      return o;
    }

    function scale(c,s){
      const o=document.createElement('canvas');
      o.width=Math.max(1,Math.round(c.width*s));
      o.height=Math.max(1,Math.round(c.height*s));
      const g=o.getContext('2d');
      g.imageSmoothingEnabled=false;
      g.drawImage(c,0,0,o.width,o.height);
      return o;
    }

    function getImageData(c){
      return c.getContext('2d',{willReadFrequently:true}).getImageData(0,0,c.width,c.height);
    }

      async function tryDecodeCanvas(cnv){
        // 1) BarcodeDetector: preferisce QRJ1 se presente
        if (barcodeDetector){
          try{
            const codes = await barcodeDetector.detect(cnv);
            if (codes?.length){
              // cerca esplicitamente un QR con prefisso QRJ1:
              const qrj = codes.find(c =>
                typeof c.rawValue === "string" &&
                c.rawValue.startsWith("QRJ1:")
              );
              if (qrj) return qrj.rawValue;

              // altrimenti comportati come prima: primo con rawValue valido
              const first = codes.find(c => typeof c.rawValue === "string" && c.rawValue.length);
              if (first) return first.rawValue;
            }
          }catch{}
        }
        
        async function tryDecodeCanvasNoBD(cnv){
          // come tryDecodeCanvas, ma SENZA BarcodeDetector

          if (zxingReader && typeof zxingReader.decodeFromCanvas === 'function'){
            try{
              const r = await zxingReader.decodeFromCanvas(cnv);
              if (r?.text) return r.text;
            }catch(e){}
          }

          if (typeof jsQR === 'function'){
            try{
              const id = getImageData(cnv);
              const r = jsQR(id.data, id.width, id.height, { inversionAttempts: "attemptBoth" });
              if (r?.data) return r.data;
            }catch(e){}
          }

          return null;
        }

        // 2) ZXing (fallback singolo QR)
        if (zxingReader && typeof zxingReader.decodeFromCanvas === 'function'){
          try{
            const r = await zxingReader.decodeFromCanvas(cnv);
            if (r?.text) return r.text;
          }catch{}
        }

        // 3) jsQR (fallback singolo QR)
        if (typeof jsQR === 'function'){
          try{
            const id = getImageData(cnv);
            const r = jsQR(id.data, id.width, id.height, { inversionAttempts:"attemptBoth" });
            if (r?.data) return r.data;
          }catch{}
        }

        return null;
      }

      async function robustDecodeFromCanvas(baseCanvas){
        // üîπ FAST PATH: prova tutti i decoder solo sul canvas base
        const fast = await tryDecodeCanvas(baseCanvas);
        if (fast) return fast;

        // üîπ FALLBACK ROBUSTO: rotazioni / scale / filtri,
        // ma SENZA pi√π chiamare BarcodeDetector ogni volta
        const vars = [baseCanvas, toGray(baseCanvas), otsu(baseCanvas)];
        const ang  = [0, 90, 180, 270];
        const sc   = [1.0, 1.4, 1.8, 2.2];

        for (const a of ang){
          const rot = vars.map(v => a ? rotate(v, a) : v);

          for (const s of sc){
            for (const v of rot){
              // salta il caso (ang=0, scale=1, baseCanvas) gi√† provato sopra
              if (a === 0 && Math.abs(s - 1) < 1e-3 && v === baseCanvas) continue;

              const c = (Math.abs(s - 1) < 1e-3) ? v : scale(v, s);
              const t = await tryDecodeCanvasNoBD(c);
              if (t) return t;
            }
          }
        }

        return null;
      }

    async function robustDecodeFromImage(imgEl){
      const base=drawToCanvas(imgEl);
      return robustDecodeFromCanvas(base);
    }

      async function decodeFromPDF(file){
        if(!pdfjsLib) throw new Error("pdf.js non caricato");

        // 1) Carico il PDF e renderizzo la prima pagina su un canvas
        const arrBuf = await file.arrayBuffer();
        const pdf = await pdfjsLib.getDocument({data:arrBuf}).promise;
        const page = await pdf.getPage(1);

        const viewport = page.getViewport({scale: 2});
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        canvas.width  = viewport.width;
        canvas.height = viewport.height;

        await page.render({ canvasContext: ctx, viewport }).promise;

        // 2) Ritaglio la zona dove sta il QR grande con il JSON
        //    (coerente con come lo hai disegnato nel PDF: in alto a destra)
        const pageWmm = 297;  // A4 orizzontale in mm
        const pageHmm = 210;
        const qrSizeMm = 80;
        const marginTmm = 20;
        const qrTopOffsetMm = 12;
        const qrXmm = pageWmm - qrSizeMm - 20;        // come nel generatore
        const qrYmm = marginTmm + qrTopOffsetMm;
        const padMm = 10;                             // margine extra attorno al QR

        const scaleX = canvas.width  / pageWmm;
        const scaleY = canvas.height / pageHmm;

        const cropX = Math.max(0, Math.floor((qrXmm - padMm) * scaleX));
        const cropY = Math.max(0, Math.floor((qrYmm - padMm) * scaleY));
        const cropW = Math.min(
          canvas.width  - cropX,
          Math.ceil((qrSizeMm + 2 * padMm) * scaleX)
        );
        const cropH = Math.min(
          canvas.height - cropY,
          Math.ceil((qrSizeMm + 2 * padMm) * scaleY)
        );

        const cropCanvas = document.createElement("canvas");
        cropCanvas.width  = cropW;
        cropCanvas.height = cropH;
        const cropCtx = cropCanvas.getContext("2d");

        // copio solo il quadrato intorno al QR grande
        cropCtx.drawImage(
          canvas,
          cropX, cropY,         // sorgente (pagina intera)
          cropW, cropH,
          0, 0,                 // destinazione
          cropW, cropH
        );

        // 3) Prima provo a decodificare SOLO la zona ritagliata
        let text = await robustDecodeFromCanvas(cropCanvas);
        if (text) return text;

        // 4) Fallback: se per qualche motivo non va, torno al comportamento vecchio
        text = await robustDecodeFromCanvas(canvas);
        return text;
      }

    // HTTPS warning
    (function(){
      const isSecure = (
        location.protocol === 'https:' ||
        location.hostname === 'localhost' ||
        location.hostname === '127.0.0.1'
      );

      const decStat  = document.getElementById('decStatus');

      if (!isSecure) {
        if (decStat && !decStat.innerHTML.trim()){
          decStat.innerHTML =
            '<span class="warn">Se la webcam live non parte, prova HTTPS o usa "Carica immagine / foto QR".</span>';
        }
      } else {
        if (decStat && !decStat.innerHTML.trim()){
          decStat.textContent = "Puoi usare webcam live fullscreen o caricare immagine/PDF.";
        }
      }
    })();

    // anti double-tap zoom iOS
    (function(){
      let lastTouch = 0;
      document.addEventListener('touchend', function(e){
        const now = Date.now();
        const dt = now - lastTouch;
        if (dt > 0 && dt < 300) {
          e.preventDefault();
        }
        lastTouch = now;
      }, { passive:false });
    })();

      // üóëÔ∏è Rimosso 'let lastPayloadText="";' duplicato

      // üÜï Corretta la logica per forzare il reflow e riattivare la transizione.
            function flashTick(durationMs=90){
              const el = document.getElementById('tickFlash');
              if(!el) return;
              
              // 1. Rimuovi immediatamente la classe per resettare lo stato
              el.classList.remove('show');
              
              // 2. Forza il reflow/repaint del browser.
              // Questo √® CRUCIALE perch√© il browser registra il cambio di stato e prepara la transizione.
              void el.offsetWidth;
              
              // 3. Aggiungi la classe 'show' per avviare la transizione CSS (opacity: 0.7)
              el.classList.add('show');
              
              // 4. Pianifica la rimozione della classe per spegnere il flash
              setTimeout(()=>el.classList.remove('show'), durationMs);
            }

      /* üîä AUDIO SYSTEM SENZA FILE ESTERNI (Web Audio API) */
      const KEY_SOUND = 'qrj1_sound_enabled';
      let soundEnabled = (localStorage.getItem(KEY_SOUND) !== 'false'); // default true
      let audioCtx = null;
      // üÜï IMPOSTA IL GUADAGNO MASSIMO QUI (VALORE MAX 1.0)
      const MAX_GAIN = 0.5; // Aumenta questo valore (es. a 1.0) se vuoi il suono pi√π forte possibile.

      function initAudio(){
        if(!audioCtx){
          const AC = window.AudioContext || window.webkitAudioContext;
          if(AC) audioCtx = new AC();
        }
        if(audioCtx && audioCtx.state === 'suspended'){
          audioCtx.resume().catch(()=>{});
        }
      }

      function playTone(freq, type='sine', duration=0.1){
        if(!soundEnabled) return;
        initAudio();
        if(!audioCtx) return;

        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();

        osc.frequency.value = freq;
        osc.type = type;
        
        // üÜï MODIFICA QUI: Inizializza il volume al MAX_GAIN e poi fallo decadere.
          // Questo render√† il suono molto pi√π forte rispetto a 0.1
          gain.gain.setValueAtTime(MAX_GAIN, audioCtx.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + duration)

        osc.connect(gain);
        gain.connect(audioCtx.destination);

        osc.start();
        osc.stop(audioCtx.currentTime + duration);
      }

      // Toggle Button Logic
      const sndBtn = document.getElementById('cntSoundToggle');
      function updateSoundBtn(){
        if(sndBtn){
           sndBtn.textContent = soundEnabled ? "üîä" : "üîá";
           sndBtn.classList.toggle('active', soundEnabled);
        }
      }
      if(sndBtn){
        sndBtn.addEventListener('click', ()=>{
          soundEnabled = !soundEnabled;
          localStorage.setItem(KEY_SOUND, soundEnabled);
          updateSoundBtn();
        });
        updateSoundBtn();
      }
      /* -------------------------------------------------- */

      function haptic(type='tick'){
        // Audio feedback
        if(type==='tick') playTone(600, 'sine', 0.08); // bip normale (conteggio +)
        if(type==='tock') playTone(300, 'triangle', 0.1); // bip basso (conteggio -, delete)
        if(type==='reset') playTone(150, 'sawtooth', 0.2); // bip svuotamento
        if(type==='success') playTone(900, 'sine', 0.05); // bip successo (all done)
        if(type==='light') playTone(500, 'sine', 0.04); // bip leggero (save, load, tab, gen QR)
        if(type==='error') playTone(100, 'square', 0.3); // bip errore

        // Haptic feedback
        try{
          if(!navigator.vibrate) return;
          if(type==='tick') navigator.vibrate(12);
          if(type==='tock') navigator.vibrate(20);
          if(type==='reset') navigator.vibrate([20,10,20]);
          if(type==='success') navigator.vibrate([5,5,5]);
          if(type==='light') navigator.vibrate(5);
          if(type==='error') navigator.vibrate([100,50,100]);
        }catch{}
        
        // Visual feedback
        if(type==='error') flashTick(150); // errore pi√π lungo
        else flashTick(90);
      }

    /* === Counter overlay logic === */
    let currentCounterIndex = -1;
    const counterOverlay = document.getElementById('counterOverlay');
    const counterClose   = document.getElementById('counterClose');
    const cntDesc        = document.getElementById('cntDesc');
    const cntPrev        = document.getElementById('cntPrev');
    const cntValueEl     = document.getElementById('cntValue');
    const cntMinus       = document.getElementById('cntMinus');
    const cntPlus        = document.getElementById('cntPlus');
    const cntReset       = document.getElementById('cntReset');
    let currentStep = 1; // step di default per +/‚àí

    function openCounter(index){
      // üÜï Normalizza lo stato all'apertura
      state = normalizeState(state);
      
      if(index<0 || !state || !state.l || index>=state.l.length) return;
      
      // Inizializza audio al primo tocco utente (necessario per policy browser)
      initAudio();

      currentCounterIndex = index;
      const it = state.l[index];
      cntDesc.textContent = it.d || "";
      cntPrev.textContent = String(it.q);
      cntValueEl.textContent = String(it.r || 0);
      counterOverlay.style.display='flex';
      document.documentElement.style.overflow='hidden';
      document.body.style.overflow='hidden';

      // preset di default se non impostato
      if (!currentStep || isNaN(currentStep)) currentStep = 1;

      const presetButtons = document.querySelectorAll('#counterOverlay .presetBtn');
      let found = false;
      presetButtons.forEach(b=>{
        const step = parseInt(b.getAttribute('data-step'),10) || 1;
        if (!found && step === currentStep){
          b.classList.add('active');
          found = true;
        } else {
          b.classList.remove('active');
        }
      });

      // se per qualche motivo non ne abbiamo trovato uno, attiva "1"
      if (!found && presetButtons.length){
        currentStep = parseInt(presetButtons[0].getAttribute('data-step'),10) || 1;
        presetButtons.forEach((b,i)=>{
          b.classList.toggle('active', i===0);
        });
      }
    }
    function closeCounter(){
      counterOverlay.style.display='none';
      document.documentElement.style.overflow='';
      document.body.style.overflow='';
      currentCounterIndex = -1;
    }
    if (counterClose) counterClose.addEventListener('click', closeCounter);
    if (counterOverlay) counterOverlay.addEventListener('click', (e)=>{
      if(e.target===counterOverlay) closeCounter();
    });

      // single-tap (no press&hold repeat), usa currentStep
      if (cntMinus) cntMinus.addEventListener('click', ()=>{
        if(currentCounterIndex<0) return;
        const it = state.l[currentCounterIndex];
        const step = currentStep || 1;

        const oldV = it.r || 0;
        let v = oldV - step;
        v = Math.max(0, v);

        if (v === oldV) return;

        it.r = v;
        cntValueEl.textContent = String(v);
        haptic('tock'); // suono grave
        saveLocal(state);
        updateProgress();
        syncRowFromCounter(currentCounterIndex, v);
      });

      if (cntPlus) cntPlus.addEventListener('click', ()=>{
        if(currentCounterIndex<0) return;
        const it = state.l[currentCounterIndex];
        const step = currentStep || 1;

        const oldV = it.r || 0;
        let v = oldV + step;
        v = Math.min(it.q, v);

        if (v === oldV) return;

        it.r = v;
        cntValueEl.textContent = String(v);
        haptic('tick'); // suono acuto
        saveLocal(state);
        updateProgress();
        syncRowFromCounter(currentCounterIndex, v);
      });

      if (cntReset) cntReset.addEventListener('click', ()=>{
        if(currentCounterIndex<0) return;
        const it = state.l[currentCounterIndex];
        const oldV = it.r || 0;

        if (oldV === 0) return;

        it.r = 0;
        cntValueEl.textContent = "0";
        haptic('reset'); // suono reset
        saveLocal(state);
        updateProgress();
        syncRowFromCounter(currentCounterIndex, 0);
      });

      // preset = scelta del passo per +/‚àí
      const presetButtons = document.querySelectorAll('#counterOverlay .presetBtn');
      presetButtons.forEach(btn=>{
        btn.addEventListener('click', ()=>{
          const step = parseInt(btn.getAttribute('data-step'),10) || 1;
          currentStep = step;
          // evidenzia il preset selezionato
          presetButtons.forEach(b=>b.classList.remove('active'));
          btn.classList.add('active');
        });
      });

    function syncRowFromCounter(i,v){
      const rows = document.querySelectorAll('#rTbl tbody tr');
      const tr = rows[i]; if(!tr) return;
      const inp = tr.querySelector('.rQtyInputBig');
      if(inp){ inp.value=String(v); }
      const prev = state.l[i].q;
      const manca = Math.max(0, prev - v);
      
      const mancaCell = tr.querySelector('.mancaCell');
      if(mancaCell) mancaCell.textContent = String(manca);
      
      // Aggiorniamo anche la cella rientro se visibile (desktop) o se nascosta (mobile) per coerenza
      // ma su mobile √® hidden. L'importante √® l'input.
    }
    /* === End counter overlay logic === */
  </script>
  <div id="tickFlash"></div>
</body>
</html>
