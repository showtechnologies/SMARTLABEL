<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
  <title>Inventario QR ‚Äì Mobile</title>
  <style>
    :root{
      --gap:14px;--muted:#6b7280;--b:#e5e7eb;--ok:#10b981;--warn:#f59e0b;--err:#ef4444;
      --bg:#0b0f14;--card:#0f141b;--text:#e5e7eb;--accent:#4f46e5;
      /* usata per altezza iOS 100vh corretta */
      --vh: 1vh;
    }

    *{box-sizing:border-box}

    html,body{height:100%}

    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      -webkit-font-smoothing:antialiased;
    }

    header{
      position:sticky;
      top:0;
      background:linear-gradient(180deg,#0b0f14 0%, #0b0f14cc 100%);
      backdrop-filter:blur(8px);
      border-bottom:1px solid #1114;
      z-index:1000;
    }

    .wrap{
      max-width:980px;
      margin:0 auto;
      padding:16px;
    }

    h1{
      margin:0 0 6px;
      font-size:20px;
      letter-spacing:.2px;
      line-height:1.2;
      display:flex;
      flex-wrap:wrap;
      align-items:baseline;
      gap:8px;
    }

    h1 .opNameTag{
      font-size:12px;
      line-height:1.2;
      color:#9aa6b2;
      background:#1f2937;
      border:1px solid #374151;
      border-radius:8px;
      padding:3px 6px;
      font-weight:500;
    }

    nav{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
    }

    nav button{
      flex:1 1 auto;
      min-width:0;
      border:1px solid #202635;
      background:#121824;
      border-radius:12px;
      padding:10px 12px;
      cursor:pointer;
      color:var(--text);
      font-size:14px;
      line-height:1.2;
      text-align:center;
    }

    nav button.active{
      background:var(--accent);
      border-color:var(--accent);
      color:#fff;
      font-weight:600;
    }

    nav button[data-tab="tab-home"]{
      flex-basis:100%;
    }

    @media(min-width:768px){
      nav button{
        flex-grow:0;
        flex-basis:auto;
        font-size:13px;
        padding:8px 10px;
        border-radius:10px;
      }
      nav button[data-tab="tab-home"]{
        flex-basis:auto;
      }
    }

    h2{
      margin:14px 0 8px;
      font-size:18px;
    }

    .grid{
      display:grid;
      gap:var(--gap);
    }

    .cols-2{
      grid-template-columns:1fr;
    }

    @media(min-width:900px){
      .cols-2{grid-template-columns:1fr 1fr}
    }

    .card{
      background:var(--card);
      border:1px solid #1b2230;
      border-radius:16px;
      padding:14px;
      position:relative;
    }

    label{
      font-size:12px;
      color:var(--muted);
      display:block;
      margin-bottom:6px;
    }

    input,
    textarea,
    select{
      width:100%;
      border:1px solid #253043;
      background:#0f141b;
      border-radius:12px;
      padding:12px 14px;
      color:var(--text);
      font-family:inherit;
      font-size:16px;
      line-height:1.3;
    }

    input::placeholder,
    textarea::placeholder{
      color:#94a3b8;
    }

    table{
      width:100%;
      border-collapse:collapse;
    }

    th,
    td{
      padding:10px;
      border-bottom:1px solid #1b2230;
      text-align:left;
      font-size:14px;
      vertical-align:top;
    }

    .table-scroll{
      width:100%;
      overflow-x:auto;
    }

    .row{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:flex-end;
    }

    .row .btn{
      flex-shrink:0;
    }

    .row.actions-wrap{
      justify-content:flex-start;
    }

    .row.actions-wrap .btn{
      flex:1 1 calc(50% - 10px);
      text-align:center;
    }

    @media(min-width:480px){
      .row.actions-wrap .btn{
        flex:0 0 auto;
      }
    }

    .btn{
      border:1px solid #253043;
      border-radius:12px;
      padding:12px 14px;
      background:var(--accent);
      color:#fff;
      cursor:pointer;
      font-size:15px;
      line-height:1.2;
    }

    .btn.ghost{
      background:#121824;
      color:var(--text);
    }

    .btn.warnBtn{
      background:#b91c1c;
      border-color:#dc2626;
    }

    .btn.sm{
      padding:8px 10px;
      font-size:13px;
      line-height:1.2;
      border-radius:10px;
    }

    @media(min-width:1024px){
      .btn{
        padding:10px 12px;
        font-size:14px;
      }
      .btn.sm{
        padding:6px 8px;
        font-size:12px;
      }
    }

    .muted{color:#9aa6b2}
    .ok{color:var(--ok)}
    .warn{color:var(--warn)}
    .err{color:var(--err)}

    .qrbox{
      display:flex;
      align-items:center;
      justify-content:center;
      min-height:260px;
      background:#0b0f14;
      border:1px dashed #22304a;
      border-radius:16px;
    }

    .qrbox canvas{
      width:260px !important;
      height:260px !important;
      image-rendering:pixelated;
    }

    .mono{
      font-family:ui-monospace,Menlo,Consolas,monospace;
      white-space:pre-wrap;
      font-size:13px;
      line-height:1.4;
    }

    video,
    canvas{
      max-width:100%;
    }

    .hidden{display:none}

    .home-cta{
      display:grid;
      grid-template-columns:1fr;
      gap:12px;
      margin-top:8px;
    }

    .cta{
      display:flex;
      align-items:center;
      gap:12px;
      border:1px solid #22304a;
      background:#0f141b;
      border-radius:16px;
      padding:16px;
      cursor:pointer;
    }

    .cta .icon{
      width:44px;
      height:44px;
      border-radius:12px;
      display:flex;
      align-items:center;
      justify-content:center;
      background:#182034;
      font-size:20px;
      flex-shrink:0;
    }

    .cta .title{
      font-weight:600;
      font-size:15px;
      line-height:1.3;
      color:var(--text);
    }

    .cta .desc{
      font-size:12px;
      color:#9aa6b2;
      line-height:1.4;
    }

    @media(min-width:760px){
      .home-cta{
        grid-template-columns:1fr 1fr;
      }
    }

    .progress{
      height:12px;
      background:#1b2230;
      border-radius:999px;
      overflow:hidden;
      border:1px solid #253043;
    }

    .progress>span{
      display:block;
      height:100%;
      background:linear-gradient(90deg,#22c55e,#16a34a);
      width:0%;
    }

    .r-toolbar{
      position:sticky;
      top:0;
      background:var(--card);
      border-bottom:1px solid #1b2230;
      border-radius:16px 16px 0 0;
      padding-bottom:12px;
      z-index:3;
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    .r-toolbar-sec{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
    }

    .r-toolbar-sec .btn{
      flex:1 1 calc(50% - 10px);
      text-align:center;
    }

    @media(min-width:600px){
      .r-toolbar-sec .btn{
        flex:0 0 auto;
      }
    }

    .r-progress-block{
      border-top:1px solid #1b2230;
      padding-top:8px;
    }

    .r-table-wrap{
      max-height:60vh;
      overflow-y:auto;
      margin-top:12px;
      border-top:1px solid #1b2230;
      padding-top:12px;
    }

    #rTbl th, #rTbl td{
      font-size:14px;
      line-height:1.3;
    }

    .rCtrl{
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:nowrap;
    }

    .rQtyInputBig{
      width:72px;
      text-align:center;
      font-size:18px;
      line-height:1.2;
      background:#0f141b;
      border:1px solid #253043;
      border-radius:10px;
      color:var(--text);
      padding:10px;
      flex-shrink:0;
    }

    /* ----------- WEBCAM (PATCH) ----------- */
    #cameraOverlay{
      position:fixed;
      inset:0;
      background:#000;
      color:#fff;
      z-index:3000;
      display:none;             /* diventa flex in startCameraOverlay */
      flex-direction:column;
      height:calc(var(--vh, 1vh) * 100); /* iOS vh reale */
    }

    #cameraHeader{
      display:flex;
      justify-content:space-between;
      align-items:center;
      padding:12px 16px;
      background:rgba(0,0,0,.6);
      color:#fff;
      font-size:14px;
      line-height:1.3;
      z-index:10;
    }
    #cameraHeader .cam-status{
      flex:1;
      min-width:0;
      color:#fff;
    }
    #cameraHeader .cam-actions{
      display:flex;
      gap:10px;
    }
    #cameraHeader button{
      background:#111827;
      border:1px solid #374151;
      color:#fff;
      border-radius:10px;
      padding:8px 10px;
      font-size:13px;
      line-height:1.2;
    }

    #cameraVideoWrap{
      flex:1;                 /* occupa tutto lo spazio sotto l‚Äôheader */
      min-height:0;
      position:relative;
      overflow:hidden;
      background:#000;
      display:block;
    }

    #cameraVideo{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      object-fit:cover;
      background:#000;
      border-radius:0;
    }

    #cameraCanvas{ display:none; }
    /* --------- FINE PATCH WEBCAM ----------- */

    /* ----------- LOGIN OVERLAY ----------- */
    #loginOverlay{
      position:fixed !important;
      inset:0;
      height:calc(var(--vh, 1vh) * 100);
      background:rgba(0,0,0,.8);
      color:#fff;
      z-index:4000;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:24px;
    }
    /* --------- FINE LOGIN OVERLAY ----------- */

    /* ----------- COUNTER OVERLAY ----------- */
    #counterOverlay{
      position:fixed;
      inset:0;
      height:calc(var(--vh, 1vh) * 100);
      background:rgba(0,0,0,.85);
      color:#fff;
      z-index:5000;
      display:none; /* diventa flex in openCounter */
      flex-direction:column;
    }
    #counterHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding:14px 16px;
      background:rgba(0,0,0,.6);
      border-bottom:1px solid #222;
    }
    #counterTitle{
      font-size:16px;
      line-height:1.3;
      font-weight:600;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    #counterClose{
      background:#1f2937;
      border:1px solid #374151;
      color:#fff;
      border-radius:10px;
      padding:8px 10px;
      font-size:14px;
      line-height:1.2;
      cursor:pointer;
    }
    #counterBody{
      flex:1;
      display:flex;
      flex-direction:column;
      gap:16px;
      padding:16px;
    }
    .cntInfo{
      display:flex;
      gap:12px;
      flex-wrap:wrap;
      font-size:14px;
      color:#d1d5db;
    }
    .cntValue{
      font-size:56px;
      font-weight:700;
      text-align:center;
      padding:8px 0 4px;
    }
    .cntButtons{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:14px;
      margin-top:8px;
    }
    .bigCountBtn{
      display:flex;
      align-items:center;
      justify-content:center;
      min-height:120px;
      font-size:42px;
      font-weight:700;
      border-radius:24px;
      cursor:pointer;
      border:1px solid #374151;
      background:#111827;
      color:#fff;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .bigCountBtn.minus{ background:#7f1d1d; border-color:#b91c1c; }
    .bigCountBtn.plus { background:#065f46; border-color:#065f46; }
    .cntFoot{
      margin-top:auto;
      text-align:center;
      color:#9aa6b2;
      font-size:12px;
    }
    .countBtn{ white-space:nowrap; }
    /* --------- FINE COUNTER OVERLAY ----------- */
  </style>
</head>
<body>
  <header>
    <div class="wrap">
      <h1>
        Inventario QR
        <span id="opNameTag" class="opNameTag hidden"></span>
      </h1>
      <nav class="noprint">
        <button data-tab="tab-home" class="active">Home</button>
        <button data-tab="tab-lista">Crea lista</button>
        <button data-tab="tab-qr">QR & Stampa</button>
        <button data-tab="tab-decode">Leggi lista</button>
        <button data-tab="tab-rientro">Spunta</button>
        <span id="status" class="muted" style="margin-left:auto;flex-grow:0;flex-basis:auto"></span>
      </nav>
    </div>
  </header>

  <div class="wrap">
    <!-- HOME -->
    <section id="tab-home" class="tab">
      <div class="home-cta">
        <div class="cta" data-go="tab-lista">
          <div class="icon">üìù</div>
          <div>
            <div class="title">Crea lista</div>
            <div class="desc">ID baule, evento, materiali, PDF/etichetta.</div>
          </div>
        </div>
        <div class="cta" data-go="tab-decode">
          <div class="icon">üì∑</div>
          <div>
            <div class="title">Leggi lista</div>
            <div class="desc">Scansiona QR o PDF per controllare / caricare rientro.</div>
          </div>
        </div>
      </div>
    </section>

    <!-- LISTA -->
    <section id="tab-lista" class="tab hidden">
      <h2>Lista articoli</h2>
      <div class="grid cols-2">
        <div class="card">
          <div class="row">
            <div style="flex:1">
              <label>ID baule</label>
              <input id="boxId" placeholder="Es. B-07">
            </div>
            <div style="flex:2">
              <label>Evento</label>
              <input id="eventName" placeholder="Es. Concerto Piazza">
            </div>
          </div>
          <div class="row" style="margin-top:10px">
            <div style="flex:3">
              <label>Descrizione</label>
              <input id="desc" placeholder="Es. Faro LED PAR 64">
            </div>
            <div style="flex:1">
              <label>Quantit√†</label>
              <input id="qty" type="number" min="1" value="1">
            </div>
            <button id="addItem" class="btn">Aggiungi</button>
          </div>
        </div>
        <div class="card">
          <div class="row actions-wrap">
            <button id="saveLocal" class="btn ghost">Salva in locale</button>
            <button id="loadLocal" class="btn ghost">Carica da locale</button>
            <button id="clearList" class="btn ghost warnBtn">Svuota lista</button>
            <button id="exportJson" class="btn ghost">Esporta JSON</button>
          </div>
          <div class="muted" style="margin-top:6px">Il salvataggio locale usa <code>localStorage</code>.</div>
        </div>
      </div>

      <div class="card">
        <div class="table-scroll">
          <table id="itemsTbl">
            <thead>
              <tr>
                <th>#</th>
                <th>Descrizione</th>
                <th>Q.t√†</th>
                <th class="noprint">Azioni</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
    </section>

    <!-- QR & STAMPA -->
    <section id="tab-qr" class="tab hidden">
      <h2>QR & Stampa</h2>
      <div class="grid cols-2">
        <div class="card">
          <div class="row">
            <div style="flex:1;min-width:140px">
              <label>Produzione</label>
              <input id="prodName" placeholder="es. Festival XYZ">
            </div>
            <div style="flex:1;min-width:140px">
              <label>Posizione</label>
              <input id="posName" placeholder="es. Palco lato DX">
            </div>
          </div>

          <div class="row" style="margin-top:10px">
            <div style="flex:1;min-width:140px">
              <label>Note</label>
              <input id="noteField" placeholder="es. FOH / wedge spare">
            </div>
            <div style="flex:1;min-width:140px">
              <label>Colore etichetta</label>
              <select id="colorSel">
                <option value="0">Rosso</option>
                <option value="1">Arancione</option>
                <option value="2">Giallo</option>
                <option value="3">Verde</option>
                <option value="4">Blu</option>
                <option value="5">Viola</option>
                <option value="6">Bianco/Nessuno</option>
              </select>
            </div>
          </div>

          <div class="row" style="margin-top:10px">
            <button id="btnGenQR" class="btn">Genera QR / Aggiorna anteprima</button>
            <button id="btnDownloadPNG" class="btn ghost" disabled>Scarica PNG QR</button>
            <button id="btnPrint" class="btn ghost" disabled>Stampa etichetta</button>
            <button id="btnPDFMain" class="btn ghost" disabled>PDF etichetta</button>
          </div>
          <div class="muted" style="margin-top:6px">
            QRJ1 (zlib+Base45) ‚Ä¢ ECC=H ‚Ä¢ QR fisso grande per lettura al buio.<br>
            Il bordo colore segue quello scelto qui.
          </div>

          <div id="qrBox" class="qrbox" aria-live="polite"></div>
          <div id="encInfo" class="muted"></div>
        </div>

        <div class="card">
          <label>JSON canonico utilizzato</label>
          <textarea id="jsonCanon" rows="16" class="mono" readonly></textarea>
          <div class="muted">SHA-256: <span id="sha256" class="mono"></span></div>
        </div>
      </div>
    </section>

    <!-- DECODE -->
    <section id="tab-decode" class="tab hidden">
      <h2>Leggi/Verifica QR o PDF</h2>
      <div class="grid cols-2">
        <div class="card">
          <div class="row">
            <div style="flex:1;min-width:180px">
              <label>Carica immagine o PDF</label>
              <input id="fileInput" type="file" accept="image/*,application/pdf">
            </div>

            <div style="flex:1;min-width:180px">
              <label>Scatta foto QR (solo immagine)</label>
              <input id="cameraShot" type="file" accept="image/*" capture="environment">
            </div>
          </div>

          <div style="margin-top:10px">
            <label>‚Ä¶oppure usa webcam live (fullscreen)</label>
            <div class="row">
              <button id="btnCam" class="btn ghost">Apri webcam</button>
            </div>
          </div>

          <div id="decStatus" class="muted" style="margin:12px 0 8px"></div>

          <label style="margin-top:12px;display:block;">Testo letto</label>
          <div id="rawOut" class="mono muted"></div>

          <div class="row" style="margin-top:10px">
            <button id="btnSetCurrent" class="btn" disabled>Usa come lista corrente</button>
            <button id="btnCompare" class="btn ghost" disabled>Confronta con lista corrente</button>
          </div>
        </div>
        <div class="card">
          <label>JSON ricostruito</label>
          <textarea id="jsonDecoded" rows="16" class="mono"></textarea>
          <div id="cmpResult" class="muted"></div>
        </div>
      </div>
    </section>

    <!-- RIENTRO -->
    <section id="tab-rientro" class="tab hidden">
      <h2>Spunta articoli</h2>
      <div class="card">
        <div class="r-toolbar">
          <div class="r-toolbar-sec">
            <button id="rReset" class="btn ghost">Azzera tutto</button>
            <button id="rAll"   class="btn ghost">Tutti rientrati</button>
            <button id="rExport" class="btn ghost">Esporta CSV</button>
            <button id="rPDF" class="btn">PDF rientro</button>
          </div>

          <div class="r-progress-block">
            <div class="muted" style="margin:8px 0 6px">Avanzamento rientro</div>
            <div class="progress" aria-label="Progresso rientro"><span id="rBar" style="width:0%"></span></div>
            <div id="rPct" class="muted" style="margin-top:6px">0% ‚Ä¢ 0/0</div>
            <div id="rInfo" class="muted"></div>
          </div>
        </div>

        <div class="r-table-wrap">
          <div class="table-scroll">
            <table id="rTbl">
              <thead>
                <tr>
                  <th>#</th>
                  <th>Descrizione</th>
                  <th>Prev.</th>
                  <th>Rientro</th>
                  <th>Manca</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
        </div>

      </div>
    </section>
  </div>

  <!-- LOGIN OVERLAY -->
  <div id="loginOverlay">
    <div id="loginCard">
      <h2>Chi sta usando l'app?</h2>
      <p>Metti il tuo nome. Verr√† stampato sull'etichetta e sul PDF.<br>Rimane salvato in questo dispositivo.</p>
      <div class="row" style="gap:10px">
        <input id="loginNameInput" placeholder="Es. Luca R." autocomplete="name">
        <button id="loginBtn" class="btn">Entra</button>
      </div>
    </div>
  </div>

  <!-- CAMERA OVERLAY -->
  <div id="cameraOverlay">
    <div id="cameraHeader">
      <div class="cam-status" id="camStatus">Inizializzo camera‚Ä¶</div>
      <div class="cam-actions">
        <button id="toggleFlashBtn" class="hidden">Flash</button>
        <button id="closeCamBtn" class="btn sm ghost" style="background:#7f1d1d;border-color:#b91c1c">Chiudi</button>
      </div>
    </div>
    <div id="cameraVideoWrap">
      <video id="cameraVideo" autoplay playsinline muted></video>
      <canvas id="cameraCanvas"></canvas>
    </div>
  </div>

  <!-- COUNTER OVERLAY -->
  <div id="counterOverlay" aria-modal="true" role="dialog">
    <div id="counterHeader">
      <div id="counterTitle">Contatore</div>
      <button id="counterClose" aria-label="Chiudi">‚úï</button>
    </div>
    <div id="counterBody">
      <div class="cntInfo">
        <div><strong>Descrizione:</strong> <span id="cntDesc"></span></div>
        <div><strong>Previsto:</strong> <span id="cntPrev"></span></div>
      </div>
      <div class="cntValue" id="cntValue">0</div>
      <div class="cntButtons">
        <div class="bigCountBtn minus" id="cntMinus">‚àí</div>
        <div class="bigCountBtn plus"  id="cntPlus">+</div>
      </div>
      <div class="cntFoot">Tocca per contare. Salvataggio immediato.</div>
    </div>
  </div>

  <!-- SERVICE WORKER -->
  <script>
    const CACHE_VERSION='qrj1-mobile-v5';
    const PRECACHE=[
      'https://cdn.jsdelivr.net/pyodide/v0.25.1/full/pyodide.js',
      'https://cdn.jsdelivr.net/pyodide/v0.25.1/full/pyodide.asm.wasm',
      'https://cdn.jsdelivr.net/pyodide/v0.25.1/full/pyodide.asm.data',
      'https://cdn.jsdelivr.net/pyodide/v0.25.1/full/packages.json',

      'https://cdn.jsdelivr.net/npm/@zxing/library@0.21.2/umd/index.min.js',
      'https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js',
      'https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.js',

      'https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js',
      'https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.min.js',
      'https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.worker.min.js'
    ];

    if('serviceWorker' in navigator){
      const sw=`
        const C='${CACHE_VERSION}', PREC=${JSON.stringify(PRECACHE)};
        self.addEventListener('install',e=>e.waitUntil((async()=>{
          const c=await caches.open(C);
          await c.addAll(PREC);
          self.skipWaiting();
        })()));
        self.addEventListener('activate',e=>e.waitUntil((async()=>{
          const ks=await caches.keys();
          await Promise.all(ks.map(k=>{if(k!==C)return caches.delete(k)}));
          self.clients.claim();
        })()));
        self.addEventListener('fetch',e=>{
          const u=e.request.url;
          if (PREC.some(p=>u.startsWith(p.split('/').slice(0,5).join('/'))||u===p)){
            e.respondWith((async()=>{
              const c=await caches.open(C);
              const m=await c.match(e.request);
              if(m) return m;
              try{
                const f=await fetch(e.request,{cache:'no-store'});
                if(f&&f.ok) c.put(e.request,f.clone());
                return f;
              }catch{
                return m||Response.error();
              }
            })());
          }
        });
      `;
      const blob=new Blob([sw],{type:'text/javascript'});
      const url=URL.createObjectURL(blob);
      navigator.serviceWorker.register(url).catch(()=>{});
    }
  </script>

  <!-- APP SCRIPT -->
  <script>
    const PYODIDE_URL="https://cdn.jsdelivr.net/pyodide/v0.25.1/full/pyodide.js";
    const ZXING_URL="https://cdn.jsdelivr.net/npm/@zxing/library@0.21.2/umd/index.min.js";
    const JSQR_URL="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js";
    const QRG_URL="https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.js";
    const JSPDF_URL="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js";
    const PDFJS_URL="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.min.js";
    const PDFJS_WORKER_URL="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.worker.min.js";

    let pyodide,
        zxingReader=null,
        barcodeDetector=null,
        currentQRCanvas=null,
        decodedObj=null;

    let jsPDFmod=null,
        pdfjsLib=null;

    // camera state
    let camStream=null;
    let camScanning=false;
    let camTrack=null;
    let torchEnabled=false;

    // stato globale
    const KEY_STORE='qrj1_simple_list_v5';
    const KEY_OP='qrj1_operator';
    let state = loadLocal() || {
      v:1,
      t:today(),
      b:"",
      e:"",
      p:"",
      pos:"",
      note:"",
      c:0,
      l:[]
    };
    let operatorName = loadOperatorName() || "";

    // ------- COUNTER (popup) -------
    let currentCounterIndex = -1;

    // LOGIN
    document.addEventListener('DOMContentLoaded', ()=>{
      const loginBtn = document.getElementById('loginBtn');
      const loginNameInput = document.getElementById('loginNameInput');

      loginBtn.addEventListener('click', ()=>{
        const name = loginNameInput.value.trim();
        if(!name){
          alert("Inserisci un nome.");
          return;
        }
        operatorName = name;
        saveOperatorName(operatorName);
        updateOperatorLabel();
        showLoginOverlay(false);
      });

      // ENTER per inviare
      loginNameInput.addEventListener('keydown', (e)=>{
        if(e.key === 'Enter'){
          e.preventDefault();
          loginBtn.click();
        }
      });

      if(operatorName){
        updateOperatorLabel();
        showLoginOverlay(false);
      }else{
        showLoginOverlay(true);
      }
    });

    function showLoginOverlay(show){
      const ov=document.getElementById('loginOverlay');
      ov.style.display = show ? 'flex':'none';
      document.documentElement.style.overflow = show ? 'hidden' : '';
      document.body.style.overflow = show ? 'hidden' : '';
    }

    function loadOperatorName(){
      try{ return localStorage.getItem(KEY_OP) || ""; }catch{ return ""; }
    }
    function saveOperatorName(n){
      try{ localStorage.setItem(KEY_OP,n); }catch{}
    }
    function updateOperatorLabel(){
      const tag=document.getElementById('opNameTag');
      if(operatorName){
        tag.textContent = operatorName;
        tag.classList.remove('hidden');
      }else{
        tag.textContent = "";
        tag.classList.add('hidden');
      }
    }

    // ------- PATCH iOS 100vh reale -------
    function setVH(){
      document.documentElement.style.setProperty('--vh', (window.innerHeight * 0.01) + 'px');
    }
    window.addEventListener('resize', setVH);
    window.addEventListener('orientationchange', setVH);
    setVH();
    // -------------------------------------

    // BOOT
    ;(async()=>{
      setStatus("Carico runtime‚Ä¶");

      await loadScript(PYODIDE_URL);
      await Promise.all([
        loadScript(ZXING_URL),
        loadScript(JSQR_URL),
        loadScript(QRG_URL),
        loadScript(JSPDF_URL),
        loadScript(PDFJS_URL),
        loadScript(PDFJS_WORKER_URL)
      ]);

      pyodide = await loadPyodide({ indexURL:"https://cdn.jsdelivr.net/pyodide/v0.25.1/full/" });
      await initPython();
      await initDecoders();

      jsPDFmod = window.jspdf;
      pdfjsLib = window['pdfjs-dist/build/pdf'];
      if (pdfjsLib) {
        pdfjsLib.GlobalWorkerOptions.workerSrc = PDFJS_WORKER_URL;
      }

      setStatus("Pronto (offline dopo primo avvio).");
      applyMeta();
      renderTables();
      unlockButtons();
    })();

    function unlockButtons(){
      document.getElementById('btnGenQR').disabled=false;
      document.getElementById('btnDownloadPNG').disabled=true;
      document.getElementById('btnPrint').disabled=true;
      document.getElementById('btnPDFMain').disabled=true;
    }

    function loadScript(src){
      return new Promise((res,rej)=>{
        const s=document.createElement('script');
        s.src=src;
        s.onload=res;
        s.onerror=rej;
        document.head.appendChild(s);
      });
    }

    function setStatus(t){
      document.getElementById('status').textContent=t;
    }

    async function initPython(){
      await pyodide.runPythonAsync(`
import json, zlib
_CH="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:"
_MAP={c:i for i,c in enumerate(_CH)}
def b45encode(data: bytes) -> str:
    out=[]; i=0; n=len(data)
    while i<n:
        if i+1<n:
            x=(data[i]<<8)|data[i+1]
            out.extend((_CH[x//(45*45)], _CH[(x//45)%45], _CH[x%45])); i+=2
        else:
            x=data[i]; out.extend((_CH[x//45], _CH[x%45])); i+=1
    return "".join(out)
def b45decode(s: str) -> bytes:
    buf=bytearray(); i=0; n=len(s)
    while i<n:
        if i+2<n:
            x=_MAP[s[i]]*45*45 + _MAP[s[i+1]]*45 + _MAP[s[i+2]]
            buf+=bytes([(x>>8)&0xFF, x&0xFF]); i+=3
        else:
            x=_MAP[s[i]]*45 + _MAP[s[i+1]]
            buf.append(x&0xFF); i+=2
    return bytes(buf)
SCHEME="QRJ1:"
def pack_json_str(s: str) -> str:
    comp=zlib.compress(s.encode("utf-8"),9)
    return SCHEME + b45encode(comp)
def unpack_to_pretty(s: str) -> str:
    if not s.startswith(SCHEME):
        raise ValueError("prefisso QRJ1: mancante")
    payload=s[len(SCHEME):]
    data=zlib.decompress(b45decode(payload)).decode("utf-8")
    obj=json.loads(data)
    return json.dumps(obj, ensure_ascii=False, indent=2)
      `);
    }

    async function initDecoders(){
      if('BarcodeDetector' in window){
        try{
          const fmts = await BarcodeDetector.getSupportedFormats?.()||[];
          if(fmts.includes('qr_code')||fmts.length){
            barcodeDetector=new BarcodeDetector({formats:['qr_code']});
          }
        }catch{}
      }
      zxingReader=new ZXing.BrowserMultiFormatReader();
    }

    // UTIL
    function today(){
      const d=new Date();
      return d.toISOString().slice(0,10);
    }

    function nowStamp(){
      const d = new Date();
      const yy=d.getFullYear();
      const mm=String(d.getMonth()+1).padStart(2,"0");
      const dd=String(d.getDate()).padStart(2,"0");
      const hh=String(d.getHours()).padStart(2,"0");
      const mi=String(d.getMinutes()).padStart(2,"0");
      return `${yy}-${mm}-${dd} ${hh}:${mi}`;
    }

    function loadLocal(){
      try{
        const s=localStorage.getItem(KEY_STORE);
        const obj=s?JSON.parse(s):null;
        if(!obj) return null;
        if(obj.p===undefined)   obj.p="";
        if(obj.pos===undefined) obj.pos="";
        if(obj.note===undefined)obj.note="";
        if(obj.c===undefined)   obj.c=0;
        if(!obj.l) obj.l=[];
        return obj;
      }catch{
        return null;
      }
    }

    function saveLocal(obj){
      try{
        localStorage.setItem(KEY_STORE, JSON.stringify(obj));
      }catch{}
    }

    function escapeHtml(s){
      return s.replace(/[&<>"]/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c]));
    }

    function canonicalJSON(obj, includeRientro){
      const o = {
        v:1,
        t: obj.t || today(),
        b: obj.b || "",
        e: obj.e || "",
        o: operatorName || "",
        p: obj.p || "",
        pos: obj.pos || "",
        note: obj.note || "",
        c: (typeof obj.c==="number"?obj.c:0),
        l: (obj.l||[]).map(x=>({
          d:x.d,
          q:x.q,
          r:(includeRientro ? (x.r||0) : 0)
        }))
      };

      return JSON.stringify(o,(k,v)=>{
        if(Array.isArray(v)) return v;
        if(v && typeof v==='object'){
          const out={};
          Object.keys(v).sort().forEach(k=>out[k]=v[k]);
          return out;
        }
        return v;
      });
    }

    async function sha256hex(s){
      const buf=new TextEncoder().encode(s);
      const h=await crypto.subtle.digest('SHA-256', buf);
      return [...new Uint8Array(h)].map(b=>b.toString(16).padStart(2,'0')).join('');
    }

    function dataURLtoBlob(dataURL){
      const b=atob(dataURL.split(',')[1]);
      const len=b.length;
      const u8=new Uint8Array(len);
      for(let i=0;i<len;i++) u8[i]=b.charCodeAt(i);
      return new Blob([u8],{type:'image/png'});
    }

    function downloadBlob(blob, name){
      const a=document.createElement('a');
      a.href=URL.createObjectURL(blob);
      a.download=name;
      a.click();
      setTimeout(()=>URL.revokeObjectURL(a.href), 4000);
    }

    function colorFromIndex(i){
      switch(i){
        case 0: return [220,38,38];
        case 1: return [245,158,11];
        case 2: return [250,204,21];
        case 3: return [16,185,129];
        case 4: return [59,130,246];
        case 5: return [139,92,246];
        case 6: return [255,255,255];
        default:return [255,255,255];
      }
    }

    function colorNameFromIndex(i){
      switch(i){
        case 0: return "ROSSO";
        case 1: return "ARANCIONE";
        case 2: return "GIALLO";
        case 3: return "VERDE";
        case 4: return "BLU";
        case 5: return "VIOLA";
        case 6: return "BIANCO / NESSUNO";
        default: return "BIANCO / NESSUNO";
      }
    }

    function slugify(s){
      return (s || "")
        .trim()
        .replace(/\s+/g,"_")
        .replace(/[^A-Za-z0-9_\-]+/g,"");
    }

    // NAV
    document.querySelectorAll('nav button[data-tab]').forEach(b=>{
      b.onclick=()=>goTab(b.dataset.tab,true);
    });
    document.querySelectorAll('[data-go]').forEach(el=>{
      el.onclick=()=>goTab(el.getAttribute('data-go'),true);
    });

    function goTab(id,fromUser=false){
      document.querySelectorAll('nav button').forEach(x=>x.classList.remove('active'));
      const nb=[...document.querySelectorAll('nav button[data-tab]')].find(b=>b.dataset.tab===id);
      if(nb) nb.classList.add('active');
      document.querySelectorAll('.tab').forEach(t=>t.classList.add('hidden'));
      document.getElementById(id).classList.remove('hidden');
      if(fromUser) window.scrollTo({top:0,behavior:'smooth'});
    }

    // META FIELDS
    const boxIdEl      = document.getElementById('boxId');
    const eventNameEl  = document.getElementById('eventName');
    const prodNameEl   = document.getElementById('prodName');
    const posNameEl    = document.getElementById('posName');
    const noteFieldEl  = document.getElementById('noteField');
    const colorSelEl   = document.getElementById('colorSel');

    boxIdEl.value     = state.b || "";
    eventNameEl.value = state.e || "";

    function syncMeta(){
      state.b = boxIdEl.value.trim();
      state.e = eventNameEl.value.trim();
      state.p = prodNameEl.value.trim()   || state.p || "";
      state.pos = posNameEl.value.trim()  || state.pos || "";
      state.note = noteFieldEl.value.trim()|| state.note||"";
      state.c = parseInt(colorSelEl.value||"0",10);
      state.t = state.t || today();
    }

    function applyMeta(){
      boxIdEl.value     = state.b || "";
      eventNameEl.value = state.e || "";
      prodNameEl.value  = state.p || "";
      posNameEl.value   = state.pos || "";
      noteFieldEl.value = state.note || "";
      colorSelEl.value  = (typeof state.c==="number"?state.c:0);
    }

    // LISTA HANDLERS
    document.getElementById('addItem').onclick=()=>{
      const d=document.getElementById('desc').value.trim();
      const q=parseInt(document.getElementById('qty').value||"0",10);
      if(!d || q<=0){
        alert("Inserisci descrizione e quantit√† > 0");
        return;
      }
      ensureRientroStore();
      state.l.push({d,q,r:0});
      document.getElementById('desc').value="";
      document.getElementById('qty').value="1";
      renderTables();
    };

    document.getElementById('saveLocal').onclick=()=>{
      syncMeta();
      saveLocal(state);
      alert("Salvato in locale.");
    };

    document.getElementById('loadLocal').onclick=()=>{
      const s=loadLocal();
      if(s){
        state=s;
        applyMeta();
        renderTables();
        updateProgress();
        saveLocal(state);
      } else {
        alert("Nessun dato locale.");
      }
    };

    document.getElementById('clearList').onclick=()=>{
      if(confirm("Svuotare la lista?")){
        state.l=[];
        renderTables();
      }
    };

    document.getElementById('exportJson').onclick=()=>{
      syncMeta();
      const j = canonicalJSON(state,true);
      downloadBlob(new Blob([j],{type:'application/json'}),'lista.json');
    };

    function renderTables(){
      // tabella lista articoli
      const tb=document.querySelector('#itemsTbl tbody');
      tb.innerHTML="";
      state.l.forEach((it,idx)=>{
        const tr=document.createElement('tr');
        tr.innerHTML=`
          <td>${idx+1}</td>
          <td>${escapeHtml(it.d)}</td>
          <td>${it.q}</td>
          <td class="noprint">
            <button class="btn sm ghost" data-del="${idx}">Elimina</button>
          </td>`;
        tb.appendChild(tr);
      });
      tb.querySelectorAll('button[data-del]').forEach(b=>{
        b.onclick=()=>{
          const i=parseInt(b.dataset.del,10);
          state.l.splice(i,1);
          renderTables();
          updateProgress();
          saveLocal(state);
        };
      });

      // tabella rientro
      renderRientroTable();
    }

    // QR & PDF buttons
    const btnGenQR        = document.getElementById('btnGenQR');
    const btnDownloadPNG  = document.getElementById('btnDownloadPNG');
    const btnPrint        = document.getElementById('btnPrint');
    const btnPDFMain      = document.getElementById('btnPDFMain');

    btnGenQR.onclick = async ()=>{
      if(!pyodide){
        alert("Runtime non pronto, ricarica la pagina.");
        return;
      }
      syncMeta();

      if(!state.b || !state.e){
        alert("Compila ID baule ed Evento.");
        return;
      }

      const canon = canonicalJSON(state,true);
      document.getElementById('jsonCanon').value = canon;
      document.getElementById('sha256').textContent = await sha256hex(canon);

      let packed;
      try{
        packed = await pyodide.runPythonAsync(
          `pack_json_str(${JSON.stringify(canon)})`
        );
      }catch(e){
        alert("Errore pack Python: "+e);
        return;
      }
      lastPayloadText = packed;

      const border = 4;
      currentQRCanvas = makeQrCanvas(lastPayloadText, border);

      const box=document.getElementById('qrBox');
      box.innerHTML="";
      box.appendChild(currentQRCanvas);

      document.getElementById('encInfo').textContent =
        `ECC=H. Quiet zone ${border} moduli.`;

      btnDownloadPNG.disabled=false;
      btnPrint.disabled=false;
      btnPDFMain.disabled=false;
    };

    btnDownloadPNG.onclick=()=>{
      if(!currentQRCanvas) return;
      const DPI=300;
      const qrSizeMm = 80;
      const px=Math.round((qrSizeMm/25.4)*DPI);
      const out=document.createElement('canvas');
      out.width=px;
      out.height=px;
      const g=out.getContext('2d');
      g.imageSmoothingEnabled=false;
      g.fillStyle='#fff';
      g.fillRect(0,0,px,px);
      g.drawImage(currentQRCanvas,0,0,px,px);
      downloadBlob(dataURLtoBlob(out.toDataURL('image/png')), 'qr_baule.png');
    };

    btnPrint.onclick=()=>{
      generateAndHandlePDF("etichetta","print");
    };

    btnPDFMain.onclick=()=>{
      generateAndHandlePDF("etichetta","download");
    };

    document.getElementById('rPDF').onclick=()=>{
      generateAndHandlePDF("rientro","download");
    };

    function makeQrCanvas(text, borderMods){
      const typeNumber=0;
      const qr = qrcode(typeNumber, 'H');
      qr.addData(text);
      qr.make();

      const m=qr.getModuleCount();
      const mp=m+borderMods*2;
      const px=Math.max(512, mp*10);
      const c=document.createElement('canvas');
      c.width=px;
      c.height=px;
      const g=c.getContext('2d');
      g.imageSmoothingEnabled=false;
      g.fillStyle='#fff';
      g.fillRect(0,0,px,px);
      const s=px/mp;
      g.fillStyle='#000';
      for(let r=0;r<m;r++){
        for(let col=0;col<m;col++){
          if(qr.isDark(r,col)){
            g.fillRect(
              Math.round((col+borderMods)*s),
              Math.round((r+borderMods)*s),
              Math.ceil(s),
              Math.ceil(s)
            );
          }
        }
      }
      return c;
    }

    function ensureRientroStore(){
      if(!state.l){ state.l=[]; }
      state.l = state.l.map(it=>({
        d:it.d,
        q:it.q,
        r:(typeof it.r==="number"?it.r:0)
      }));
      if(state.p===undefined)   state.p="";
      if(state.pos===undefined) state.pos="";
      if(state.note===undefined)state.note="";
      if(state.c===undefined)   state.c=0;
    }

    // === PDF (identico alla tua versione con i fix precedenti) ===
    function generateAndHandlePDF(mode, action){
      const FONT_HEADER = 12;
      const FONT_CELL = 12;
      const TABLE_LINE = 0.35;

      if(!jsPDFmod || !pyodide){
        alert("Runtime non pronto, ricarica la pagina.");
        return;
      }

      const { jsPDF } = jsPDFmod;
      const doc = new jsPDF({ orientation:"landscape", unit:"mm", format:"a4" });

      ensureRientroStore();
      syncMeta();

      let incompleto = false;
      state.l.forEach(it=>{ if ((it.r||0) < it.q) incompleto=true; });

      const marginL = 15;
      const marginT = 20;
      const pageW   = 297;
      const pageH   = 210;

      const FRAME_INSET = 8;
      const FOOTER_AREA = 12;
      function drawPageFrame(d){
        d.setDrawColor(0,0,0);
        d.setLineWidth(0.6);
        d.roundedRect(
          FRAME_INSET,
          FRAME_INSET,
          pageW - 2*FRAME_INSET,
          pageH - 2*FRAME_INSET - FOOTER_AREA,
          6, 6, "S"
        );
      }
      drawPageFrame(doc);

      function addFooter(d){
        d.setFont("helvetica","normal");
        d.setFontSize(10);
        d.setTextColor(100,100,100);
        const footerText = "Show Technologies‚Ñ¢ - info@showtechnologies.it - +39(0)185720185";
        const textW = d.getTextWidth(footerText);
        const x = (pageW - textW)/2;
        const y = pageH - 8;
        d.text(footerText, x, y);
        d.setTextColor(0,0,0);
      }

      let curY = marginT;
      if (mode === "rientro"){
        if (incompleto){
          doc.setFont("helvetica","bold");
          doc.setFontSize(32);
          doc.setTextColor(255,0,0);
          doc.text("INCOMPLETO", marginL, curY);
        } else {
          doc.setFont("helvetica","bold");
          doc.setFontSize(24);
          doc.setTextColor(16,185,129);
          doc.text("TUTTO RIENTRATO", marginL, curY);
        }
        doc.setTextColor(0,0,0);
        curY += 14;
      }

      doc.setFont("helvetica","normal");
      doc.setFontSize(FONT_CELL);

      const tableX = marginL;
      const tableY = curY;
      const rowH   = 7;
      const labelW = 35;
      const valueW = 100;
      const radius = 2.0;

      const rowsMeta = [
        ["Operatore:", operatorName || ""],
        ["Evento:",    state.e || ""],
        ["Produzione:", state.p || ""],
        ["ID Baule:", state.b || ""],
        ["Note:", state.note || ""],
        ["Stampato:", nowStamp()]
      ];
      const metaTableW = labelW + valueW;
      const metaTableH = rowsMeta.length * rowH;

      doc.setDrawColor(0,0,0);
      doc.setLineWidth(TABLE_LINE);
      doc.roundedRect(tableX, tableY, metaTableW, metaTableH, radius, radius, "S");

      for(let i=1;i<rowsMeta.length;i++){
        const y = tableY + i*rowH;
        doc.line(tableX, y, tableX+metaTableW, y);
      }
      doc.line(tableX+labelW, tableY, tableX+labelW, tableY+metaTableH);

      rowsMeta.forEach((row,i)=>{
        const yTextBase = tableY + i*rowH + (rowH-2);
        doc.text(row[0], tableX+2, yTextBase);
        const vLines = doc.splitTextToSize(row[1], valueW-4);
        doc.text(vLines, tableX+labelW+2, yTextBase);
      });

      const qrSizeMm = 80;
      const qrX = pageW - qrSizeMm - 20;
      // controlli distanza simmetrica (puoi regolare qui)
      const QR_TOP_OFFSET = 12;
      const GAP_AROUND_QR = 12;

      const qrY = marginT + QR_TOP_OFFSET;

      const canon = canonicalJSON(state,true);

      pyodide.runPythonAsync(
        `pack_json_str(${JSON.stringify(canon)})`
      ).then(qp=>{
        const qrCanvas = makeQrCanvas(qp, 4);
        const qrDataURL = qrCanvas.toDataURL("image/png");

        const rgb = colorFromIndex(state.c || 0);
        doc.setDrawColor(rgb[0], rgb[1], rgb[2]);
        doc.setLineWidth(3);
        const pad=4;
        doc.roundedRect(
          qrX - pad/2,
          qrY - pad/2,
          qrSizeMm + pad,
          qrSizeMm + pad,
          3,3,"S"
        );

        doc.addImage(qrDataURL, "PNG", qrX, qrY, qrSizeMm, qrSizeMm);

        if ((state.pos || "").trim()) {
          doc.setFont("helvetica","bold");
          doc.setFontSize(20);
          const posText = state.pos.trim();
          const desiredPosY = qrY - GAP_AROUND_QR;
          const safeTop = marginT + 6;
          const posY = Math.max(safeTop, desiredPosY);
          doc.text(posText, qrX + qrSizeMm/2, posY, { align: "center" });
        }

        const colorLabel = colorNameFromIndex(state.c || 0);
        doc.setFont("helvetica","bold");
        doc.setFontSize(20);
        doc.setTextColor(0,0,0);
        const colorY = qrY + qrSizeMm + GAP_AROUND_QR;
        doc.text(colorLabel, qrX + qrSizeMm/2, colorY, { align: "center" });

        const maxRightBeforeQR = qrX - 10;
        const matStartY = tableY + metaTableH + 8;

        drawMaterialsTable(doc, {
          startY: matStartY,
          leftX: marginL,
          maxRight: maxRightBeforeQR,
          mode: mode,
          marginT: marginT,
          pageW: pageW,
          pageH: pageH,
          addFooterFn: addFooter
        });

        addFooter(doc);

        const baseName =
          slugify(state.p || state.e || "Evento") + "_" +
          slugify(state.b || "Baule") +
          (mode==="rientro" ? "_RIENTRO" : "");

        if(action === "download"){
          doc.save(baseName + ".pdf");
        }else{
          const blobUrl = doc.output("bloburl");
          window.open(blobUrl, "_blank");
        }
      });

      function drawMaterialsTable(doc, cfg){
        let yCursor = cfg.startY;

        doc.setFont("helvetica","bold");
        doc.setFontSize(16);
        if (cfg.mode === "rientro"){
          doc.text("Rientro materiali:", cfg.leftX, yCursor);
        } else {
          doc.text("Materiali:", cfg.leftX, yCursor);
        }
        yCursor += 8;

        const availableW = Math.max(60, (cfg.maxRight - cfg.leftX));
        const ratiosRientro = [0.68, 0.10, 0.12, 0.10];
        const ratiosNormale = [0.82, 0.18];

        let headers, colWidths;
        if (cfg.mode === "rientro"){
          headers   = ["Descrizione","Prev.","Rientrati","Manca"];
          colWidths = ratiosRientro.map(r => Math.round(r * availableW));
        } else {
          headers   = ["Descrizione","Q.t√†"];
          colWidths = ratiosNormale.map(r => Math.round(r * availableW));
        }

        // correzione arrotondamenti
        {
          const sumW = colWidths.reduce((a,b)=>a+b,0);
          let diff = availableW - sumW;
          let k = 0;
          while (diff !== 0 && k < 50){
            const idx = k % colWidths.length;
            if (diff > 0) colWidths[idx] += 1;
            else if (diff < 0 && colWidths[idx] > 1) colWidths[idx] -= 1;
            k++;
            const ssum = colWidths.reduce((a,b)=>a+b,0);
            diff = availableW - ssum;
          }
        }

        const finalTableW = colWidths.reduce((a,b)=>a+b,0);
        const headH = 9;
        const baseLineH = 8;
        const textLineStep = 6;

        function buildRowObjects(){
          const rowsOut=[];
          rowsOut.push({ type:"header", cells: headers, h: headH, descLines: null });

          state.l.forEach(it=>{
            const prev = it.q;
            const rin  = it.r || 0;
            const manc = Math.max(0, prev - rin);

            const descCell = it.d || "";
            const descLines = doc.splitTextToSize(descCell, colWidths[0]-4);
            let rowH = baseLineH;
            const dynH = 4 + (descLines.length * textLineStep);
            if (dynH > rowH) rowH = dynH;

            let cells;
            if (cfg.mode === "rientro"){
              cells = [descLines, String(prev), String(rin), String(manc)];
            } else {
              cells = [descLines, String(prev)];
            }

            rowsOut.push({ type:"data", cells, h: rowH, descLines });
          });

          return rowsOut;
        }

        const allRows = buildRowObjects();

        function drawTablePage(rowIndex, startY){
          let yTopTable = startY;
          let curRow = rowIndex;

          let rowsThisPage = [];
          let totalH = 0;
          for(let i=curRow;i<allRows.length;i++){
            const h = allRows[i].h;
            if (yTopTable + totalH + h + 20 > cfg.pageH) break;
            rowsThisPage.push(allRows[i]);
            totalH += h;
          }

          if(rowsThisPage.length===0 && curRow<allRows.length){
            rowsThisPage.push(allRows[curRow]);
            totalH += allRows[curRow].h;
          }

          const radiusOuter = 2.0;
          doc.setDrawColor(0,0,0);
          doc.setLineWidth(TABLE_LINE);
          doc.roundedRect(cfg.leftX, yTopTable, finalTableW, totalH, radiusOuter, radiusOuter, "S");

          let xCursor = cfg.leftX;
          for(let c=0;c<colWidths.length-1;c++){
            xCursor += colWidths[c];
            doc.line(xCursor, yTopTable, xCursor, yTopTable+totalH);
          }

          let drawY = yTopTable;
          for(let r=0;r<rowsThisPage.length;r++){
            const row = rowsThisPage[r];

            if(row.type==="header"){
              doc.setFont("helvetica","bold");
              doc.setFontSize(FONT_HEADER);
            }else{
              doc.setFont("helvetica","normal");
              doc.setFontSize(FONT_CELL);
            }

            let cellX = cfg.leftX;
            for(let c=0;c<colWidths.length;c++){
              const cellW = colWidths[c];
              const cellVal = row.cells[c];
              if (Array.isArray(cellVal)){
                let textY = drawY + 6;
                cellVal.forEach(line=>{
                  doc.text(line, cellX+2, textY);
                  textY += textLineStep;
                });
              } else {
                doc.text(String(cellVal||""), cellX+2, drawY+6);
              }
              cellX += cellW;
            }

            const rowH = row.h;
            drawY += rowH;
            if(r < rowsThisPage.length-1){
              doc.line(cfg.leftX, drawY, cfg.leftX+finalTableW, drawY);
            }
          }

          return { nextRowIndex: curRow + rowsThisPage.length, nextY: drawY };
        }

        let rowIdx = 0;
        let localY = yCursor;

        while(rowIdx < allRows.length){
          const res = drawTablePage(rowIdx, localY);
          rowIdx = res.nextRowIndex;
          localY = res.nextY;

          if(rowIdx < allRows.length){
            cfg.addFooterFn(doc);
            doc.addPage("a4","landscape");
            drawPageFrame(doc);
            localY = cfg.marginT;
            doc.setFont("helvetica","bold");
            doc.setFontSize(16);
            if (cfg.mode === "rientro"){
              doc.text("Rientro materiali:", cfg.leftX, localY);
            } else {
              doc.text("Materiali:", cfg.leftX, localY);
            }
            localY += 8;
          }
        }
      }
    }

    // DECODE / SCAN
    const decStatus=document.getElementById('decStatus'),
          rawOut=document.getElementById('rawOut');
    const jsonDecoded=document.getElementById('jsonDecoded'),
          btnSetCurrent=document.getElementById('btnSetCurrent'),
          btnCompare=document.getElementById('btnCompare'),
          cmpResult=document.getElementById('cmpResult');

    document.getElementById('fileInput').addEventListener('change', async ev=>{
      const f=ev.target.files?.[0];
      if(!f) return;
      decStatus.textContent="Decodifica‚Ä¶";

      if (f.type === "application/pdf") {
        try{
          const text = await decodeFromPDF(f);
          await handleDecodedText(text);
        }catch(e){
          decStatus.innerHTML=`<span class="err">${e}</span>`;
        }
      } else {
        const url=URL.createObjectURL(f);
        try{
          const img=new Image();
          await new Promise(r=>{ img.onload=r; img.src=url; });
          const text=await robustDecodeFromImage(img);
          URL.revokeObjectURL(url);
          await handleDecodedText(text);
        }catch(e){
          URL.revokeObjectURL(url);
          decStatus.innerHTML=`<span class="err">${e}</span>`;
        }
      }
    });

    document.getElementById('cameraShot').addEventListener('change', async ev=>{
      const f=ev.target.files?.[0];
      if(!f) return;
      decStatus.textContent="Decodifica foto‚Ä¶";
      const url=URL.createObjectURL(f);
      try{
        const img=new Image();
        await new Promise(r=>{ img.onload=r; img.src=url; });
        const text=await robustDecodeFromImage(img);
        URL.revokeObjectURL(url);
        await handleDecodedText(text);
      }catch(e){
        URL.revokeObjectURL(url);
        decStatus.innerHTML=`<span class="err">${e}</span>`;
      }
    });

    const camOverlay   = document.getElementById('cameraOverlay');
    const camVideo     = document.getElementById('cameraVideo');
    const camCanvas    = document.getElementById('cameraCanvas');
    const camStatusEl  = document.getElementById('camStatus');
    const closeCamBtn  = document.getElementById('closeCamBtn');
    const toggleFlashBtn = document.getElementById('toggleFlashBtn');

    document.getElementById('btnCam').onclick = ()=>{ startCameraOverlay(); };
    closeCamBtn.onclick = ()=>{ stopCameraOverlay("Chiuso."); };
    toggleFlashBtn.onclick = ()=>{ toggleTorch(); };

    async function startCameraOverlay(){
      camOverlay.style.display='flex';
      camStatusEl.textContent="Apertura camera‚Ä¶";
      torchEnabled=false;

      try{
        camStream = await navigator.mediaDevices.getUserMedia({
          video:{
            facingMode:{ exact:'environment' },
            width:{ ideal:1280 },
            height:{ ideal:720 },
            aspectRatio:{ ideal: window.innerWidth / window.innerHeight }
          },
          audio:false
        });
      }catch(e){
        try{
          camStream = await navigator.mediaDevices.getUserMedia({
            video:{ facingMode:'environment' }, audio:false
          });
        }catch(e2){
          camStatusEl.textContent="Webcam non disponibile.";
          return;
        }
      }

      camVideo.srcObject = camStream;
      try { await camVideo.play(); } catch {}
      camTrack = camStream.getVideoTracks()[0] || null;
      camScanning = true;

      let torchCapable=false;
      if (camTrack && camTrack.getCapabilities) {
        const caps = camTrack.getCapabilities();
        torchCapable = !!caps.torch;
      }
      toggleFlashBtn.disabled = !torchCapable;
      toggleFlashBtn.classList.toggle('hidden', !torchCapable);

      camStatusEl.textContent="Inquadra il QR‚Ä¶";
      tickLiveScan();
    }

    function stopCameraOverlay(msg){
      camScanning=false;
      if(camStream){ camStream.getTracks().forEach(t=>t.stop()); camStream=null; }
      camTrack=null;
      camOverlay.style.display='none';
      camStatusEl.textContent = msg || "";
      torchEnabled=false;
    }

    async function toggleTorch(){
      if(!camTrack || !camTrack.applyConstraints) return;
      torchEnabled=!torchEnabled;
      try{
        await camTrack.applyConstraints({advanced:[{torch:torchEnabled}]});
        toggleFlashBtn.textContent = torchEnabled ? "Flash ON" : "Flash";
      }catch(e){
        camStatusEl.textContent="Flash non supportato.";
      }
    }

    async function tickLiveScan(){
      if(!camScanning || !camStream) return;

      if (camVideo.readyState === camVideo.HAVE_ENOUGH_DATA){
        camCanvas.width  = camVideo.videoWidth;
        camCanvas.height = camVideo.videoHeight;
        const gx = camCanvas.getContext('2d');
        gx.drawImage(camVideo,0,0,camCanvas.width,camCanvas.height);

        robustDecodeFromCanvas(camCanvas).then(async text=>{
          if (text && camScanning){
            camScanning=false;
            await handleDecodedText(text);
            camStatusEl.textContent="QR rilevato.";
            stopCameraOverlay("QR letto.");
          }
        });
      }

      if(camScanning){
        setTimeout(()=>{ requestAnimationFrame(tickLiveScan); },200);
      }
    }

    async function handleDecodedText(text){
      if(!text){
        decStatus.innerHTML=`<span class="warn">Nessun QR leggibile.</span>`;
        rawOut.textContent="";
        jsonDecoded.value="";
        btnSetCurrent.disabled=true;
        btnCompare.disabled=true;
        return;
      }
      rawOut.textContent=text;
      try{
        const pretty=await pyodide.runPythonAsync(
          `unpack_to_pretty(${JSON.stringify(text)})`
        );
        jsonDecoded.value=pretty;
        decodedObj=JSON.parse(pretty);

        decodedObj.l = (decodedObj.l||[]).map(it=>({ d:it.d, q:it.q, r:it.r||0 }));
        if(decodedObj.p===undefined)   decodedObj.p="";
        if(decodedObj.pos===undefined) decodedObj.pos="";
        if(decodedObj.note===undefined)decodedObj.note="";
        if(decodedObj.c===undefined)   decodedObj.c=0;

        decStatus.innerHTML=`<span class="ok">QRJ1 decodificato.</span>`;
        btnSetCurrent.disabled=false;
        btnCompare.disabled=false;
      }catch{
        jsonDecoded.value="";
        decodedObj=null;
        decStatus.innerHTML=`<span class="warn">QR letto ma non QRJ1.</span>`;
        btnSetCurrent.disabled=true;
        btnCompare.disabled=true;
      }
    }

    btnSetCurrent.onclick=()=>{
      try{
        const obj=JSON.parse(jsonDecoded.value);

        obj.l = (obj.l || []).map(item=>({ d:item.d, q:item.q, r:item.r || 0 }));
        if(obj.p===undefined)   obj.p="";
        if(obj.pos===undefined) obj.pos="";
        if(obj.note===undefined)obj.note="";
        if(obj.c===undefined)   obj.c=0;

        state=obj;
        applyMeta();
        renderTables();
        updateProgress();
        saveLocal(state);
        alert("Lista impostata come corrente.");
      }catch(e){
        alert("JSON non valido.");
      }
    };

    btnCompare.onclick=async()=>{
      try{
        const a = canonicalJSON(state,true);
        const b = canonicalJSON(JSON.parse(jsonDecoded.value),true);
        const equal = (await sha256hex(a)) === (await sha256hex(b));
        cmpResult.innerHTML = equal
          ? '<span class="ok">La lista coincide.</span>'
          : '<span class="warn">Le liste sono diverse.</span>';
      }catch(e){
        cmpResult.innerHTML=`<span class="err">${e}</span>`;
      }
    };

    // --------- RIENTRO (tabella + CONTATORE) ----------
    function renderRientroTable(){
      ensureRientroStore();
      const tb=document.querySelector('#rTbl tbody');
      tb.innerHTML="";

      let totPrev=0, totR=0;
      state.l.forEach((it,idx)=>{
        totPrev+=it.q;
        const r=it.r||0;
        totR+=Math.min(it.q, r);
        const manca=Math.max(0, it.q - r);

        const tr=document.createElement('tr');
        tr.innerHTML=`
          <td>${idx+1}</td>
          <td>${escapeHtml(it.d)}</td>
          <td>${it.q}</td>
          <td class="rCtrl">
            <input class="rQtyInputBig" type="number" min="0" max="${it.q}" value="${r}" data-i="${idx}">
            <button class="btn sm countBtn" data-i="${idx}">Conta</button>
          </td>
          <td>${manca}</td>
        `;
        tb.appendChild(tr);
      });

      // input quantit√†
      tb.querySelectorAll('.rQtyInputBig').forEach(inp=>{
        inp.addEventListener('input', ()=>{
          const i = parseInt(inp.dataset.i,10);
          let v = parseInt(inp.value || "0",10);
          if(Number.isNaN(v)) v=0;
          v=Math.max(0, Math.min(state.l[i].q, v));
          state.l[i].r=v;
          saveLocal(state);
          updateProgress();
          // aggiorna la cella "Manca" senza rerender completo
          const row = inp.closest('tr');
          const manca = Math.max(0, state.l[i].q - v);
          row.children[4].textContent = String(manca);
        });
        inp.addEventListener('change', ()=>{
          renderRientroTable(); // riallinea tutto (totali etc.)
        });
      });

      // bottone Conta -> overlay
      tb.querySelectorAll('.countBtn').forEach(btn=>{
        btn.addEventListener('click', ()=>{
          const i = parseInt(btn.dataset.i,10);
          openCounter(i);
        });
      });

      document.getElementById('rInfo').textContent=`Totale previsti: ${totPrev}`;
      updateProgress();
    }

    function updateProgress(){
      ensureRientroStore();
      let totPrev=0, totR=0;
      state.l.forEach(it=>{
        totPrev+=it.q;
        totR+=Math.min(it.q, it.r||0);
      });
      const pct = totPrev>0 ? Math.round(100*totR/totPrev) : 0;
      const bar=document.getElementById('rBar');
      bar.style.width = pct+'%';
      document.getElementById('rPct').textContent = `${pct}% ‚Ä¢ ${totR}/${totPrev}`;
    }

    document.getElementById('rReset').onclick=()=>{
      ensureRientroStore();
      state.l.forEach(it=>{it.r=0;});
      updateProgress();
      renderRientroTable();
      saveLocal(state);
    };

    document.getElementById('rAll').onclick=()=>{
      ensureRientroStore();
      state.l.forEach(it=>{it.r=it.q;});
      updateProgress();
      renderRientroTable();
      saveLocal(state);
    };

    document.getElementById('rExport').onclick=()=>{
      ensureRientroStore();
      const rows=[
        ["ID baule", state.b],
        ["Evento", state.e],
        ["Operatore", operatorName || ""],
        ["Produzione", state.p || ""],
        ["Posizione", state.pos || ""],
        ["Note", state.note || ""],
        ["Report", nowStamp()],
        [],
        ["Descrizione","Prev","Rientrati","Manca"]
      ];
      state.l.forEach((it)=>{
        const manque=Math.max(0, it.q-(it.r||0));
        rows.push([it.d, it.q, it.r||0, manque]);
      });
      const csv=rows.map(r=>r.join(";")).join("\n");
      downloadBlob(new Blob([csv],{type:'text/csv'}), 'rientro.csv');
    };

    // --------- COUNTER OVERLAY LOGIC ---------
    const counterOverlay = document.getElementById('counterOverlay');
    const counterClose   = document.getElementById('counterClose');
    const cntDesc        = document.getElementById('cntDesc');
    const cntPrev        = document.getElementById('cntPrev');
    const cntValueEl     = document.getElementById('cntValue');
    const cntMinus       = document.getElementById('cntMinus');
    const cntPlus        = document.getElementById('cntPlus');

    function openCounter(index){
      if(index<0 || index>=state.l.length) return;
      currentCounterIndex = index;
      const it = state.l[index];
      cntDesc.textContent = it.d || "";
      cntPrev.textContent = String(it.q);
      cntValueEl.textContent = String(it.r || 0);

      counterOverlay.style.display='flex';
      document.documentElement.style.overflow = 'hidden';
      document.body.style.overflow = 'hidden';
    }

    function closeCounter(){
      counterOverlay.style.display='none';
      document.documentElement.style.overflow = '';
      document.body.style.overflow = '';
      currentCounterIndex = -1;
    }

    counterClose.addEventListener('click', closeCounter);

    cntMinus.addEventListener('click', ()=>{
      if(currentCounterIndex<0) return;
      const it = state.l[currentCounterIndex];
      const v = Math.max(0, (it.r||0) - 1);
      it.r = v;
      cntValueEl.textContent = String(v);
      saveLocal(state);
      updateProgress();
      // aggiorna riga visibile
      syncRowFromCounter(currentCounterIndex, v);
    });

    cntPlus.addEventListener('click', ()=>{
      if(currentCounterIndex<0) return;
      const it = state.l[currentCounterIndex];
      const v = Math.min(it.q, (it.r||0) + 1);
      it.r = v;
      cntValueEl.textContent = String(v);
      saveLocal(state);
      updateProgress();
      syncRowFromCounter(currentCounterIndex, v);
    });

    // tocco ripetuto continuo (press-and-hold) ‚Äì opzionale
    function pressAndHold(el, onTick){
      let t=null, hold=false;
      const start=()=>{
        if(hold) return;
        hold=true;
        onTick();
        t=setTimeout(function rep(){
          onTick();
          t=setTimeout(rep, 80);
        }, 400);
      };
      const stop=()=>{
        hold=false;
        if(t){ clearTimeout(t); t=null; }
      };
      el.addEventListener('touchstart', start, {passive:true});
      el.addEventListener('mousedown', start);
      ['touchend','touchcancel','mouseup','mouseleave'].forEach(ev=>el.addEventListener(ev, stop));
    }
    pressAndHold(cntMinus, ()=>cntMinus.click());
    pressAndHold(cntPlus,  ()=>cntPlus.click());

    function syncRowFromCounter(i, v){
      const rows = document.querySelectorAll('#rTbl tbody tr');
      const tr = rows[i];
      if(!tr) return;
      const inp = tr.querySelector('.rQtyInputBig');
      if(inp){ inp.value = String(v); }
      const prev = state.l[i].q;
      const manca = Math.max(0, prev - v);
      tr.children[4].textContent = String(manca);
    }

    // QR decode helpers (come prima)
    function drawToCanvas(img){
      const c=document.createElement('canvas');
      c.width=img.naturalWidth||img.videoWidth||img.width;
      c.height=img.naturalHeight||img.videoHeight||img.height;
      c.getContext('2d',{willReadFrequently:true}).drawImage(img,0,0,c.width,c.height);
      return c;
    }
    function toGray(c){
      const ctx=c.getContext('2d',{willReadFrequently:true});
      const d=ctx.getImageData(0,0,c.width,c.height);
      const a=d.data;
      for(let i=0;i<a.length;i+=4){
        const y=(a[i]*0.2126+a[i+1]*0.7152+a[i+2]*0.0722)|0;
        a[i]=a[i+1]=a[i+2]=y;
      }
      const out=document.createElement('canvas');
      out.width=c.width;
      out.height=c.height;
      out.getContext('2d').putImageData(d,0,0);
      return out;
    }
    function otsu(c){
      const ctx=c.getContext('2d',{willReadFrequently:true});
      const d=ctx.getImageData(0,0,c.width,c.height), a=d.data, hist=new Array(256).fill(0);
      for(let i=0;i<a.length;i+=4) hist[a[i]]++;
      const total=c.width*c.height;
      let sum=0;
      for(let t=0;t<256;t++) sum+=t*hist[t];
      let sumB=0,wB=0,varMax=0,th=128;
      for(let t=0;t<256;t++){
        wB+=hist[t]; if(!wB) continue;
        const wF=total-wB; if(!wF) break;
        sumB+=t*hist[t];
        const mB=sumB/wB,mF=(sum-sumB)/wF;
        const between=wB*wF*(mB-mF)*(mB-mF);
        if(between>varMax){ varMax=between; th=t; }
      }
      for(let i=0;i<a.length;i+=4){
        const v=a[i]<th?0:255; a[i]=a[i+1]=a[i+2]=v;
      }
      const out=document.createElement('canvas');
      out.width=c.width; out.height=c.height;
      out.getContext('2d').putImageData(d,0,0);
      return out;
    }
    function rotate(c,deg){
      const o=document.createElement('canvas'), g=o.getContext('2d');
      if(deg%180===0){ o.width=c.width; o.height=c.height; }
      else{ o.width=c.height; o.height=c.width; }
      g.translate(o.width/2,o.height/2);
      g.rotate(deg*Math.PI/180);
      g.imageSmoothingEnabled=false;
      g.drawImage(c,-c.width/2,-c.height/2);
      return o;
    }
    function scale(c,s){
      const o=document.createElement('canvas');
      o.width=Math.max(1,Math.round(c.width*s));
      o.height=Math.max(1,Math.round(c.height*s));
      const g=o.getContext('2d');
      g.imageSmoothingEnabled=false;
      g.drawImage(c,0,0,o.width,o.height);
      return o;
    }
    function getImageData(c){
      return c.getContext('2d',{willReadFrequently:true}).getImageData(0,0,c.width,c.height);
    }
    async function tryDecodeCanvas(cnv){
      if(barcodeDetector){
        try{
          const codes=await barcodeDetector.detect(cnv);
          if(codes?.length && codes[0].rawValue) return codes[0].rawValue;
        }catch{}
      }
      if(zxingReader && typeof zxingReader.decodeFromCanvas==='function'){
        try{
          const r=await zxingReader.decodeFromCanvas(cnv);
          if(r?.text) return r.text;
        }catch{}
      }
      if(typeof jsQR==='function'){
        try{
          const id=getImageData(cnv);
          const r=jsQR(id.data,id.width,id.height,{inversionAttempts:"attemptBoth"});
          if(r?.data) return r.data;
        }catch{}
      }
      return null;
    }
    async function robustDecodeFromCanvas(baseCanvas){
      const vars=[baseCanvas, toGray(baseCanvas), otsu(baseCanvas)];
      const ang=[0,90,180,270], sc=[1.0,1.4,1.8,2.2];
      for(const a of ang){
        const rot=vars.map(v=>a?rotate(v,a):v);
        for(const s of sc){
          for(const v of rot){
            const c=(Math.abs(s-1)<1e-3)?v:scale(v,s);
            const t=await tryDecodeCanvas(c);
            if(t) return t;
          }
        }
      }
      return null;
    }
    async function robustDecodeFromImage(imgEl){
      const base=drawToCanvas(imgEl);
      return robustDecodeFromCanvas(base);
    }
    async function decodeFromPDF(file){
      if(!pdfjsLib) throw new Error("pdf.js non caricato");
      const arrBuf = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument({data:arrBuf}).promise;
      const page = await pdf.getPage(1);
      const viewport = page.getViewport({scale:2});
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = viewport.width;
      canvas.height = viewport.height;
      await page.render({canvasContext:ctx, viewport}).promise;
      const text = await robustDecodeFromCanvas(canvas);
      return text;
    }

    // HTTPS warning
    (function(){
      const isSecure = (
        location.protocol === 'https:' ||
        location.hostname === 'localhost' ||
        location.hostname === '127.0.0.1'
      );
      const decStat  = document.getElementById('decStatus');
      if (!isSecure) {
        if (decStat && !decStat.innerHTML.trim()){
          decStat.innerHTML =
            '<span class="warn">Se la webcam live non parte, prova HTTPS o usa "Carica immagine / foto QR".</span>';
        }
      } else {
        if (decStat && !decStat.innerHTML.trim()){
          decStat.textContent = "Puoi usare webcam live fullscreen o caricare immagine/PDF.";
        }
      }
    })();

    // anti double-tap zoom iOS
    (function(){
      let lastTouch = 0;
      document.addEventListener('touchend', function(e){
        const now = Date.now();
        const dt = now - lastTouch;
        if (dt > 0 && dt < 300) {
          e.preventDefault();
        }
        lastTouch = now;
      }, { passive:false });
    })();

    let lastPayloadText="";
  </script>
</body>
</html>
